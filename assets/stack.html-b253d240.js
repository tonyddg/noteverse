import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as n,b as e,d as a,a as d,e as i}from"./app-8c5ce49e.js";const s={},h=i('<h1 id="堆与栈" tabindex="-1"><a class="header-anchor" href="#堆与栈" aria-hidden="true">#</a> 堆与栈</h1><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><ol><li>栈 (stack): 由编译器自动分配和释放, 如存放函数的参数值, 局部变量的值</li><li>堆 (heap): 一般由程序员分配和释放, 通过 new / delete 控制, 位于 SRAM 上</li></ol><h2 id="任务分配空间" tabindex="-1"><a class="header-anchor" href="#任务分配空间" aria-hidden="true">#</a> 任务分配空间</h2><ol><li>当调用 FreeRTOS 的创建任务 API 函数 xTaskCreate() 时, FreeRTOS会在堆中开辟出一块空间, 用于存放任务的控制信息 TCB 块和栈区 Stack 用于储存任务相关的变量</li><li>TCB 块的大小取决于 FreeRTOSConfig.h 头文件中的设置 <ol><li>在最小的设置下TCB块的大小是 96 字节</li><li>如果 configUSE_TASK_NOTIFICATIONS 是1的话再增加8个字节</li><li>如果 configUSE_TRACE_FACILITY 是1的话再增加8个字节</li><li>如果 configUSE_MUTEXES 是1的话再增加8个字节</li></ol></li></ol><h2 id="msp-和-psp-栈指针" tabindex="-1"><a class="header-anchor" href="#msp-和-psp-栈指针" aria-hidden="true">#</a> MSP 和 PSP 栈指针</h2><h3 id="msp-指针" tabindex="-1"><a class="header-anchor" href="#msp-指针" aria-hidden="true">#</a> MSP 指针</h3><ul><li>主堆栈指针 (Main stack pointer)</li><li>用于操作内核以及处理异常和中断</li><li>由编译器分配</li></ul><h3 id="psp-指针" tabindex="-1"><a class="header-anchor" href="#psp-指针" aria-hidden="true">#</a> PSP 指针</h3><ul><li>用于每个任务的独立的栈指针, 用于用户的任务</li><li>在任务调度上下文切换 (context switch) 中，PSP 会初始化为相对应的任务的栈指针，如下图所示</li></ul><h2 id="内存池分配" tabindex="-1"><a class="header-anchor" href="#内存池分配" aria-hidden="true">#</a> 内存池分配</h2>',11),c=e("li",null,"当 FreeRTOS 需要 RAM 的时候，它会调用 pvPortMalloc 这个函数而不是 malloc 这个系统函数",-1),_=e("li",null,"当它需要释放内存的时候，会调用 vPortFree 这个函数而不是 free 这个系统函数",-1),p=e("li",null,"FreeRTOS 提供了五个 pvPortMalloc 和 vPortFree 的实现方案",-1),f=e("li",null,"可以在 CubeMX 中, FreeRTOS -> Config Parameters -> Memory Management Setting 中设置",-1),u={href:"https://blog.csdn.net/qq_34269632/article/details/115618386",target:"_blank",rel:"noopener noreferrer"},S=i('<h3 id="分配方案" tabindex="-1"><a class="header-anchor" href="#分配方案" aria-hidden="true">#</a> 分配方案</h3><ol><li>Heap_1 适用于小型的嵌入式系统 只能在调度器启动之前创建任务和其它内核对象, 之后任务的内存分配在程序的运行周期中保持不变并且无法被释放</li><li>Heap_2 FreeRTOS 向旧版本兼容的方案 不推荐使用</li><li>Heap_3 基于标准库 使用标准库里的 malloc 和 free 函数，所以堆的大小由链接器配置决定, 使用场景不多</li><li>Heap_4 适用于通用的应用, 也是默认应用 由一个数组表示堆, 并把数组分割成小的内存块, 堆的大小由 configTOTAL_HEAP_SIZE 定义</li><li>Heap_5 类似于Heap_4 Heap_5 可以用不同的数组空间对内存进行分配, 使用 vPortDefineHeapRegions 函数指定额外空间</li></ol><h2 id="内存管理函数" tabindex="-1"><a class="header-anchor" href="#内存管理函数" aria-hidden="true">#</a> 内存管理函数</h2><ol><li>size_t xPortGetFreeHeapSize(void); 获取堆中的剩余空间</li><li>size_t xPortGetMinimumEverFreeHeapSize(void); 获取堆的最小剩余空间, 可根据此设置堆大小, 只能在 Heap_4 或者 Heap_5 下调用</li><li>void vApplicationMallocFailedHook(void); 需要用户实现的回调函数, 在内存获取失败时调用</li></ol>',4);function m(T,x){const l=t("ExternalLinkIcon");return o(),n("div",null,[h,e("ul",null,[c,_,p,f,e("li",null,[a("由于通常的 free 与 malloc 不可使用, 在 C++ 中, 需要重载 new 与 delete, "),e("a",u,[a("参考"),d(l)])])]),S])}const F=r(s,[["render",m],["__file","stack.html.vue"]]);export{F as default};
