import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as n,e as s}from"./app-8c5ce49e.js";const i={},l=s(`<h1 id="踩坑笔记与-bug-诊断" tabindex="-1"><a class="header-anchor" href="#踩坑笔记与-bug-诊断" aria-hidden="true">#</a> 踩坑笔记与 bug 诊断</h1><h2 id="c-部分" tabindex="-1"><a class="header-anchor" href="#c-部分" aria-hidden="true">#</a> C 部分</h2><h3 id="定义结构体" tabindex="-1"><a class="header-anchor" href="#定义结构体" aria-hidden="true">#</a> 定义结构体</h3><p>c 为面向过程语言, 没有类 通常定义结构需要使用语法</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token punctuation">[</span><span class="token keyword">struct</span>类型<span class="token punctuation">]</span> 变量名<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 typedef 可以避免</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>example1<span class="token punctuation">;</span>

<span class="token comment">// 使用 typedef 不需要 struct</span>
example1 a<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">example2</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 需要 struct 标记</span>
<span class="token keyword">struct</span> <span class="token class-name">example2</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="二进制-十六进制字面量" tabindex="-1"><a class="header-anchor" href="#二进制-十六进制字面量" aria-hidden="true">#</a> 二进制/十六进制字面量</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">unsigned</span> a <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span><span class="token comment">// 十六进制字面量</span>

<span class="token keyword">unsigned</span> b <span class="token operator">=</span> <span class="token number">0</span>b1110111<span class="token punctuation">;</span><span class="token comment">// 二进制字面量</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>字面量默认为 int 型, 直接与 uint8/16 加减将溢出, <mark>使用字面量时(特别是作为二进制命令), 在最后加上 u, eg. 0xB1u</mark></p><h3 id="逻辑" tabindex="-1"><a class="header-anchor" href="#逻辑" aria-hidden="true">#</a> 逻辑</h3><p>比较两个逻辑量是否相等时, 应用异或 boolA ^ boolB , 或转为数字, 比较是否相等</p><h3 id="头文件引用" tabindex="-1"><a class="header-anchor" href="#头文件引用" aria-hidden="true">#</a> 头文件引用</h3><ol><li>避免循环引用, 如在 a.h 中 不能有 include &quot;a.h&quot;</li><li>避免隐式的循环引用, 如在 a.h 中 include &quot;b.h&quot;, b.h 中 include &quot;a.h&quot;</li></ol><h2 id="c-部分-1" tabindex="-1"><a class="header-anchor" href="#c-部分-1" aria-hidden="true">#</a> C++ 部分</h2><h3 id="类型转换" tabindex="-1"><a class="header-anchor" href="#类型转换" aria-hidden="true">#</a> 类型转换</h3><p>为了兼容 HAL 库, 必须做出部分特殊的强制类型转换</p><ol><li>const_cast 丢弃 const 属性</li><li>reinterpret_cast 以任意字长读取 (解除类型字长限制)</li></ol><h3 id="weak-修饰" tabindex="-1"><a class="header-anchor" href="#weak-修饰" aria-hidden="true">#</a> __weak 修饰</h3><p>注意 __weak 修饰的函数会自动寻找内部连接性的函数, 因此可以不 #include 相关头文件, 直接在 .cpp 内定义, 但需要使用 extern &quot;C&quot; 修饰</p><h2 id="电路部分" tabindex="-1"><a class="header-anchor" href="#电路部分" aria-hidden="true">#</a> 电路部分</h2><h3 id="电源" tabindex="-1"><a class="header-anchor" href="#电源" aria-hidden="true">#</a> 电源</h3><ol><li>PCB 上结号编号表示等位点, 结号编号相同的两个点为并联关系的等位点 当核心板任意一个 5V Vcc 节点与电源连接, 即所有 5V Vcc 节点与电源连接, 具有 5V 的电压 通过降压芯片, 使所有 3.3V Vcc 获得 3.3V 电压</li><li>任何非 5V 的电源不能与 5V Vcc 节点连接, 必须通过降压芯片</li></ol><h3 id="引脚不能供电" tabindex="-1"><a class="header-anchor" href="#引脚不能供电" aria-hidden="true">#</a> 引脚不能供电</h3><p>引脚通过核心芯片引出, 不能作为电源, 否则当电流过大, 会烧坏芯片</p><h2 id="库函数部分" tabindex="-1"><a class="header-anchor" href="#库函数部分" aria-hidden="true">#</a> 库函数部分</h2><h3 id="初始化外设" tabindex="-1"><a class="header-anchor" href="#初始化外设" aria-hidden="true">#</a> 初始化外设</h3><ol><li>库函数均通过 XXX_InitTypedef 与 XXX_Init 实现初始化</li><li>初始化的选项必然为 XXX_InitTypedef.(成员名) = (成员名)_(初始化选项)</li></ol><h3 id="标志的使用" tabindex="-1"><a class="header-anchor" href="#标志的使用" aria-hidden="true">#</a> 标志的使用</h3><ol><li>使用 XXX_GetFlagStatus(一般) / XXX_GetITStatus(中断) 获取标志信息 RESET 表示 0, SET 表示 1</li><li>通过 XXX_GetFlagStatus / XXX_GetITStatus 获得标志后, 必须使用 XXX_ClearFlag/XXX_ClearITPendingBit</li></ol><h2 id="bug-诊断部分" tabindex="-1"><a class="header-anchor" href="#bug-诊断部分" aria-hidden="true">#</a> BUG 诊断部分</h2><h3 id="通用" tabindex="-1"><a class="header-anchor" href="#通用" aria-hidden="true">#</a> 通用</h3><ol><li>任何需要初始化的函数是否在程序中调用 是否调用了 XXXInit/EnableXXX</li><li>使用外设时, 先完成各项设置/数据装载(eg. SPI 选择设备) 后, 再对外设使能(EnableXXX); 先关闭外设(DisableXXX), 再进行各项设置</li></ol><h3 id="库函数" tabindex="-1"><a class="header-anchor" href="#库函数" aria-hidden="true">#</a> 库函数</h3><ol><li>是否正确初始化时钟 RCC_XXXPeripheralClockCmd</li><li>重复使用由 XXX_Cmd(XXX, ENABLE) 开启的功能时(如 DMA), 必须先调用 XXX_Cmd(XXX, DISABLE) 关闭后再开启</li><li>将 GPIO 设置为输入/复用/重映射/EXITn时, 需要启动 AFIO 功能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</li></ol><h3 id="cube" tabindex="-1"><a class="header-anchor" href="#cube" aria-hidden="true">#</a> Cube</h3><ol><li>检查外设的初始化方式是否正确</li><li>使用外设前需要先调用 LL_XXX_Enable</li></ol><h3 id="中断" tabindex="-1"><a class="header-anchor" href="#中断" aria-hidden="true">#</a> 中断</h3><ol><li>Cube 中是否添加了 NVIC</li><li>代码中中断是否使能</li><li>UART 中的 TXE 中断最好仅在必要时开启</li></ol><h3 id="语言" tabindex="-1"><a class="header-anchor" href="#语言" aria-hidden="true">#</a> 语言</h3><ol><li>使用 C++ 时, 所有 C 部分均要使用 extern &quot;C&quot; 修饰(直接对 include 使用即可)</li><li>使用十六进制码表示指令时, 在末尾加上 u 修饰, 表示为无符号</li><li>调试中如果进入 HardFault_Handler 时, 根据调用堆栈判断出错位置</li><li>使用标准库时, 其中的 stm32f10x_it.c/h 不能注释里面已定义的中断函数</li><li>使用 DMA 时, 将数组作为传输地址时, 注意数组名即数组地址, 不需要再取地址</li><li>使用外设时, 遵守 载入数据 - 启动外设 - 关闭外设 - 读取数据 的原则</li><li><mark>不能保证结果大于 0 时, 避免无符号整型相减</mark></li></ol>`,41),t=[l];function d(c,r){return e(),n("div",null,t)}const u=a(i,[["render",d],["__file","debug.html.vue"]]);export{u as default};
