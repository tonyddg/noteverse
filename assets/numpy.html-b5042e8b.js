import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as u,c as t,b as l,d as e,a as d,w as i,e as o}from"./app-8c5ce49e.js";const s={},h=l("h1",{id:"numpy-笔记",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#numpy-笔记","aria-hidden":"true"},"#"),e(" Numpy 笔记")],-1),p={href:"https://numpy.org/doc/stable/user/basics.creation.html",target:"_blank",rel:"noopener noreferrer"},m=o('<p>默认使用 <code>import numpy as np</code> 的方式引入 Numpy 模块</p><h2 id="数组创建" tabindex="-1"><a class="header-anchor" href="#数组创建" aria-hidden="true">#</a> 数组创建</h2><p>在 Numpy 中, 最基本的数据对象即 <code>np.ndarray</code> 数组对象<br> 数组对象可以有任意的维数<br> 该对象在 Numpy 中默认视为定长的数据数组使用</p><h3 id="基于-python-的列表对象" tabindex="-1"><a class="header-anchor" href="#基于-python-的列表对象" aria-hidden="true">#</a> 基于 Python 的列表对象</h3><p>使用函数 <code>np.array(obj[, dtype])</code> 基于 Python 的列表对象如列表与元组创建数组</p><ul><li><code>obj</code> 被转换的 Python 对象</li><li><code>dtype</code> Numpy 数据类型 (与 Python 不同, 数组中的数据具有固定的长度)<br> 默认将根据被转换的数据自动选择, 因此为了防止错误, 最好明确转换的类型<br> 常用的有 <ul><li>布尔类型 <code>np.bool_</code></li><li>32 位整数类型 <code>np.int32</code></li><li>64 位浮点类型 <code>np.float64</code></li><li>双 64 位复数类型 <code>np.complex128</code></li><li>一般 Python 对象, 如字符串 <code>np.object0</code></li></ul></li></ul><p>关于 Numpy 数据类型补充: 类似 Python 的类型转换, 通过如 <code>np.float64(...)</code> 的方式可进行类型转换</p><h4 id="转换规则说明" tabindex="-1"><a class="header-anchor" href="#转换规则说明" aria-hidden="true">#</a> 转换规则说明</h4><p>对于多维的 Python 列表对象</p><ul><li>数组对象的维数与传入的 Python 列表对象维数相同</li><li>列表对象中的子列表应当均有相同的形状</li></ul><p>对于一, 二, 三维的数据, 将使用如下方法处理</p><ul><li>对于一维的数据, 得到的数组对象也是一维的<br> 注意, 不能将一维的数组对象如 <code>[1, 2, 3]</code> 作为线性代数中的向量处理</li><li>对于二维的数据, Python 列表对象最外层为 <code>n</code> 个一维的子列表, 每个列表内有 <code>m</code> 个元素, 子列表构成行, 子列表内的元素即该行中各列的元素<br> 因此可将二维的数组视为矩阵处理, 应使表示列向量时应用数组对象 <code>[[1], [2], [3]]</code></li><li>对于三维的数据, Python 列表对象最外层为 <code>k</code> 个二维的子列表, 这些子列表的处理方式与二维数据同, 因此三维的数组对象可视为一个由 <code>k</code> 个矩阵组成的数组</li></ul><h3 id="基于-numpy-的内置函数" tabindex="-1"><a class="header-anchor" href="#基于-numpy-的内置函数" aria-hidden="true">#</a> 基于 Numpy 的内置函数</h3><h4 id="生成特定形状的数组" tabindex="-1"><a class="header-anchor" href="#生成特定形状的数组" aria-hidden="true">#</a> 生成特定形状的数组</h4>',14),b=l("ul",null,[l("li",null,[l("code",null,"np.arange([start], stop[, step], dtype = None)"),e(" 生成指定步长的"),l("mark",null,"一维等差数列数组"),l("ul",null,[l("li",null,[l("code",null,"start"),e(" 数列的起始项")]),l("li",null,[l("code",null,"stop"),e(" 数列末尾 ("),l("mark",null,"不包含"),e("在数列中)")]),l("li",null,[l("code",null,"step"),e(" 数列的步长")]),l("li",null,[l("code",null,"dtype"),e(" 生成数组的数据类型 (默认将自动识别)")])])]),l("li",null,[l("code",null,"np.linspace(start, stop, num = 50, dtype = None)"),e(" 生成指定元素数的"),l("mark",null,"一维等差数列数组"),l("ul",null,[l("li",null,[l("code",null,"start"),e(" 数列的起始项")]),l("li",null,[l("code",null,"stop"),e(" 数列末项 ("),l("mark",null,"包含"),e("在数列中)")]),l("li",null,[l("code",null,"num"),e(" 数列的元素数")]),l("li",null,[l("code",null,"dtype"),e(" 生成数组的数据类型 (默认将自动识别)")])])]),l("li",null,[l("code",null,"np.logspace(start, stop, num = 50, base = 10, dtype = None)"),e(" 生成指定元素数的"),l("mark",null,"一维等比数列数组"),l("ul",null,[l("li",null,[l("code",null,"start"),e(" 数列的"),l("mark",null,"起始项的指数"),e(" (可以是正数或负数)")]),l("li",null,[l("code",null,"stop"),e(" 数列"),l("mark",null,"末项的指数"),e(" ("),l("mark",null,"包含"),e("在数列中)")]),l("li",null,[l("code",null,"num"),e(" 数列的元素数")]),l("li",null,[l("code",null,"base"),e(" 等比的底数, 默认为 "),l("code",null,"10")]),l("li",null,[l("code",null,"dtype"),e(" 生成数组的数据类型 (默认将自动识别)")])])]),l("li",null,[l("code",null,"np.eye(n[, m])"),e(" 生成指定形状的单位矩阵 (对角线上的元素为 1, 其余为 0) (二维数组) "),l("ul",null,[l("li",null,[l("code",null,"n"),e(" 矩阵的行数")]),l("li",null,[l("code",null,"m"),e(" 矩阵的列数 (默认与行数相同)")])])]),l("li",null,[l("code",null,"np.diag(list, k = 0)"),e(" 根据给定的对角线元素, 生成方阵 (二维数组) "),l("ul",null,[l("li",null,[l("code",null,"list"),e(" 对角线上的元素组成的列表")]),l("li",null,[l("code",null,"k"),e(" 对角线偏移量, 取正时向上偏移, 取负时向下偏移")])])]),l("li",null,[l("code",null,"np.zeros(shape, dtype=np.float64)"),e(" 生成一个指定形状的, 全为 0 的数组 (任意维数)"),l("br"),e(" 推荐使用此函数用于初始化空的数组 "),l("ul",null,[l("li",null,[l("code",null,"shape"),e(" 表述数组形状的元组, 如 "),l("code",null,"(3, 4)"),e(" 表示一个 "),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"3"),l("mo",null,"×"),l("mn",null,"4")]),l("annotation",{encoding:"application/x-tex"},"3\\times 4")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),l("span",{class:"mord"},"3"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"×"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6444em"}}),l("span",{class:"mord"},"4")])])]),e(" 的矩阵")]),l("li",null,[l("code",null,"dtype"),e(" 数组数据类型")])])]),l("li",null,[l("code",null,"np.ones(shape, dtype=np.float64)"),e(" 与 "),l("code",null,"np.zeros"),e(" 类似, 但元素全为 1")]),l("li",null,[l("code",null,"np.empty(shape, dtype=np.float64)"),e(" 仅根据数组形状, 申请内存空间, 其中的值是任意的, 参数与 "),l("code",null,"np.zeros"),e(" 类似"),l("br"),e(" 推荐使用此函数用于初始化所有元素即将被覆盖的数组, 用于比 "),l("code",null,"np.zeros"),e(" 更快的速度")]),l("li",null,[l("code",null,"np.random.random(shape)"),e(" 与 "),l("code",null,"np.zeros"),e(" 类似, 但元素全为 -1 ~ 1 的浮点随机数")])],-1),x=o('<h3 id="基于现有数组的组合" tabindex="-1"><a class="header-anchor" href="#基于现有数组的组合" aria-hidden="true">#</a> 基于现有数组的组合</h3><ul><li><code>np.hstack(tup)</code> 沿列增大的方向堆叠数组 <ul><li><code>tup</code> 一个由数组对象为元素的列表或元组</li><li>传入二维数组时, 要求被堆叠的数组对象具有相同的行数</li><li>传入一维数组时, 将直接按顺序拼接, 并返回一维数组</li></ul></li><li><code>np.vstack(tup)</code> 沿行增大的方向堆叠数组 <ul><li><code>tup</code> 一个由数组对象为元素的列表或元组</li><li>传入二维数组时, 要求被堆叠的数组对象具有相同的列数</li><li>传入一维数组时, 要求传入的一维数组长度均为 <code>n</code>, 并返回一个 <code>n</code> 列的二维数组</li></ul></li><li><code>np.stack(tup[, axis])</code> 沿指定方向堆叠矩阵 (建议该函数仅用于向新维度堆叠) <ul><li><code>tup</code> 一个由相同形状的数组对象为元素的列表或元组</li><li><code>axis</code> 堆叠维度, 默认为传入数组的维数加一, 即在一个新的维度上堆叠</li></ul></li><li><code>np.block(arrays)</code> 组合分块矩阵 <ul><li><code>arrays</code> 一个由二维数组数组对象为元素的二维或一维列表</li><li>传入一维列表时, 将沿列增大的方向组合, 应保证行数相同</li><li>传入二维列表时, 将子列表视为分块矩阵的行, 应保证组合时行列对齐</li></ul></li></ul><h2 id="数组的索引" tabindex="-1"><a class="header-anchor" href="#数组的索引" aria-hidden="true">#</a> 数组的索引</h2><p>假设现有 <code>n</code> 维的数组对象 <code>arrn</code>, 假设数组有 <code>len</code> 个元素</p><h3 id="基本索引" tabindex="-1"><a class="header-anchor" href="#基本索引" aria-hidden="true">#</a> 基本索引</h3><p>使用 <code>arrn[i1, i2, ..., in]</code> 即可索引数组的特定元素, 索引均从 <code>0</code> 开始</p><ul><li><p>对于二维数组, 索引数 <code>i1</code> 表示行数, <code>i2</code> 表示列数</p></li><li><p>对于三维数组, 索引数 <code>i1</code> 表示第 <code>i1</code> 个矩阵, <code>i2</code> 表示行数, <code>i3</code> 表示列数</p></li><li><p>对于 n 维数组, 总是从最外层开始索引</p></li><li><p>当使用负数 <code>-x</code> 作为索引时, 将表示索引 <code>len - x</code><br> 因此索引 <code>-1</code> 表示数组的最后一个索引</p></li><li><p>当索引缺少时, 对于之后的维数将索引整个数组</p></li></ul><h3 id="切片索引" tabindex="-1"><a class="header-anchor" href="#切片索引" aria-hidden="true">#</a> 切片索引</h3><ul><li><p>使用符号 <code>:</code> 作为索引时, 将获取整个维度下的元素, 例如 <code>arr2[:, n - 1]</code> 即可索引矩阵的第 <code>n</code> 列</p></li><li><p>使用符号 <code>i:</code> 作为索引时, 将获取从索引 <code>i</code> 开始直到最后的所有元素</p></li><li><p>使用符号 <code>:j</code> 作为索引时, 将获取从开始直到索引 <code>j</code> 的所有元素 (不包括 <code>j</code>)</p></li><li><p>使用符号 <code>i:j</code> 为以上二者的组合</p></li><li><p>使用符号 <code>i:j:k</code> 除了以 <code>i,j</code> 为边界条件外, 还将间隔 <code>k</code> 取一个元素</p></li><li><p>对于切片索引的部分都将变为一个具有 <code>g</code> 个元素的维度 (<code>g</code> 为索引得到的元素数)<br> 索引结果也将时一个维度与切片索引数相同的数组对象, 且从最外层到内的维度与切片索引对应<br> 例如 <code>arr2[:, 2]</code> 将索引数组的第 3 列, 但得到的结果依然为一维数组</p></li><li><p>可以将负数用于切片索引, 此时负数索引 <code>x</code> 将被解析为索引 <code>len - x</code></p></li><li><p>由于末端不被包含, 因此索引 <code>i:i</code> 将得到空结果</p></li></ul><h3 id="布尔索引" tabindex="-1"><a class="header-anchor" href="#布尔索引" aria-hidden="true">#</a> 布尔索引</h3><p>通过如数组的<a href="#%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97">布尔运算</a>可得到一个相同形状的, 布尔类型的数组对象</p><ul><li>当传入单个布尔数组, 布尔数组与被索引数组具有相同的形状<br> 将返回一个一维数组, 按顺序排列了布尔数组中所有为 <code>True</code> 的, 与被索引数组对应位置的元素</li><li>当传入一维布尔数组时, 类似<a href="#%E5%88%87%E7%89%87%E7%B4%A2%E5%BC%95">切片索引</a>, 要求改布尔数组与被索引维数相同, 将索引为 <code>True</code> 位置的元素</li></ul><p>例如 <code>arr[arr &gt; 10]</code> 可得到一个一维数组, 包含了数组 <code>arr</code> 中所有 <code>&gt; 10</code> 的元素</p><h3 id="数组索引" tabindex="-1"><a class="header-anchor" href="#数组索引" aria-hidden="true">#</a> 数组索引</h3><p>除了使用单个数值直接索引, 还可使用数组 (列表) 作为索引, 可一次索引多个元素<br> 多个数组作为索引时, 要求每个数组的长度相同 (但允许与其他索引方式混合使用)</p><p>多个数组索引时与<a href="#%E5%88%87%E7%89%87%E7%B4%A2%E5%BC%95">切片索引</a>不同, 数组索引的本质为分别取出各个维度中数组的第 <code>i</code> 个元素作为该维度的索引, 并将此方式的索引结果存入结果的第 <code>i</code> 个位置<br> 但当只使用一个数组索引时, 则行为与切片索引类似</p><p>例如</p><ul><li><code>arr[[0, 1, 2], [0, 1, 2]]</code> 将索引得到子数组 <code>[arr[0, 0], arr[1, 1], arr[2, 2]]</code></li><li><code>arr[0:3, 0:3]</code> 将索引得到 <code>arr</code> 左上角三行三列的子数组</li><li><code>arr[[0, 2], :]</code> 将切片数组的第</li></ul><p>除了使用 <code>[]</code> 运算符分别传入各个维度 , 还可以仅传入一个元组<br> 但此时元组中只能有数组 (即数组索引) 或数字 (即一般索引)</p><p>该方式的索引常应用于<a href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%AD%9B%E9%80%89">数组元素筛选</a></p><h3 id="平面索引" tabindex="-1"><a class="header-anchor" href="#平面索引" aria-hidden="true">#</a> 平面索引</h3><p>通过数组对象的成员 <code>flat</code><br> 使用 <code>arr.flat[n]</code> 将按元素在内存的存储顺序, 索引其中第 n - 1 个元素</p><h3 id="索引交互" tabindex="-1"><a class="header-anchor" href="#索引交互" aria-hidden="true">#</a> 索引交互</h3><p>索引数组时, 除了将索引结果作为子数组读取, 还可以对其赋值, 并且通过赋值被索引数组中的相应元素也会被修改<br> 赋值时要求右侧的变量满足以下任意条件</p><ul><li>右侧变量为单个元素, 此时子数组中所有的元素都会被赋上这个值</li><li>右侧变量与子数组具有相同的形状, 此时子数组中对应元素会被赋值</li></ul><p>注意, 此处的赋值除了一般的 <code>=</code>, 还可使用 <code>+=, *=</code> 等赋值, 实现对子数组元素的修改</p><h2 id="数组运算与广播" tabindex="-1"><a class="header-anchor" href="#数组运算与广播" aria-hidden="true">#</a> 数组运算与广播</h2><h3 id="数组运算" tabindex="-1"><a class="header-anchor" href="#数组运算" aria-hidden="true">#</a> 数组运算</h3><p>在 Numpy 中, <mark>数组的运算总是元素间运算</mark>, 即对应位置元素运算, 并将结果储存在对应位置<br> 对于线性代数运算, 见<a href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8">线性代数应用</a></p><p>当参与运算的两个数组形状不相同时, 将会尝试使用广播的方式扩展两个数组<br> 当广播失败时, 将抛出异常</p><h3 id="广播条件" tabindex="-1"><a class="header-anchor" href="#广播条件" aria-hidden="true">#</a> 广播条件</h3><p>参与广播的两个数组对象各个纬度的元素数应当满足以下条件</p><ul><li>该维度的元素数为 1</li><li>该维度的元素数相同</li><li>不存在较高的维度</li></ul><h3 id="广播行为" tabindex="-1"><a class="header-anchor" href="#广播行为" aria-hidden="true">#</a> 广播行为</h3><p>广播时住，从最高维度开始（最左侧的索引），参与运算的两个数组各自元素为 1 的维度将进行复制<br> 注意，以上所说的复制并没有实际发生，只是形式上复制</p><p>例如</p><ul><li><code>1xm</code> 的数组 <code>arr1</code> 与 <code>n x 1</code> 的数组 <code>arr2</code> 运算将分别扩展 <ul><li><code>arr1</code> 沿行复制为 <code>n x m</code>，数组的 <code>n</code> 行均相同</li><li><code>arr2</code> 沿列复制为 <code>n x m</code>，数组的 <code>m</code> 列均相同</li><li>运算时将两个扩展后的数组对应位置分别运算并存入对应位置，得到一个 <code>n x m</code> 的数组</li></ul></li><li><code>m</code> 个元素的一维数组 <code>arr1</code> 与 <code>n x m</code> 的二维数组 <code>arr2</code> 运算将分别扩展 <ul><li><code>arr1</code> 沿行复制为 <code>n x m</code>，数组的 <code>n</code> 行均相同</li><li><code>arr2</code> 不做处理</li><li>运算时将两个扩展后的数组对应位置分别运算并存入对应位置，得到一个 <code>nxm</code> 的数组</li></ul></li></ul><h3 id="数组运算-1" tabindex="-1"><a class="header-anchor" href="#数组运算-1" aria-hidden="true">#</a> 数组运算</h3><p>由广播规则可得</p><ul><li>对于一个数值与数组相乘, 相当于将数组中所有元素均乘上改数值</li><li>对于两个一维数组相乘, 将得到一个一维数组, 其中元素的值为数组对应位置相乘</li><li>对于一个 <code>1 x n</code> 的数组 (行向量) 与 <code>m x 1</code> 的数组(列向量), 无论相乘顺序如何, 总将得到一个 <code>m x n</code> 的二维数组, 其中各个元素来自对应的两个数组 (类似列向量乘以行向量)</li><li>对于两个形状相同的二维数组相乘, 得到的结果即对应元素相乘的数量积</li></ul><p>同理, 数值运算 <code>+, -, *, /, //, **</code> 以及比较运算 <code>&lt;, &gt;, &lt;=, &gt;=, ==, !=</code> 都以广播的方式进行</p><h3 id="布尔运算" tabindex="-1"><a class="header-anchor" href="#布尔运算" aria-hidden="true">#</a> 布尔运算</h3><p>根据广播规则可得, 数组对象间的比较运算得到的是一个布尔数组对象<br> 因此还需要通过布尔数组对象的特殊成员进一步判断</p><ul><li><code>arr.all()</code> 当布尔数组中所有元素均为 <code>True</code> 时返回 <code>True</code>, 可表示数组中所有元素满足要求</li><li><code>arr.any()</code> 当布尔数组中任一元素均为 <code>True</code> 时返回 <code>True</code>, 可表示数组中任一元素满足要求</li></ul><p>根据<a href="#%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97">数组运算</a>可知, 如果要比较两个数组是否完全相同应使用 <code>(matA == matB).any()</code></p><ul><li><code>matA == matB</code> 将得到一个布尔数组, 如果有不同的位置将出现为 <code>False</code> 的元素</li><li><code>.any()</code> 检查返回的布尔数组是否有 <code>False</code> 元素</li></ul><h2 id="常用数组操作" tabindex="-1"><a class="header-anchor" href="#常用数组操作" aria-hidden="true">#</a> 常用数组操作</h2><h3 id="数组信息" tabindex="-1"><a class="header-anchor" href="#数组信息" aria-hidden="true">#</a> 数组信息</h3><ul><li><code>arr.ndim</code> 获取数组的维数 <code>n</code></li><li><code>arr.size</code> 获取数组的总元素数</li><li><code>arr.shape</code> 获取数组的形状, 实际为一个 <code>n</code> 元素的元组, 包含了从高到低各维度的元素数</li><li><code>arr.dtype</code> 获取数组元素类型</li></ul><h3 id="数组变型" tabindex="-1"><a class="header-anchor" href="#数组变型" aria-hidden="true">#</a> 数组变型</h3><ul><li><code>arr.T</code> 将数组映射为其转置 (仅用于二维数组)</li><li><code>arr.flat</code> 将数组映射为一维数组</li><li><code>np.reshape(a, newshape, order = &#39;C&#39;)</code> 尝试变形数组为指定形状的数组 <ul><li><code>a</code> 被变形的数组对象或数据</li><li><code>newshape</code> 变形后数组的新形状, 即包含了新形状从高到低各维度元素数的元组</li><li><code>order</code> 变形时数据读取与放置顺序 (数组变形的本质即以特定顺序读取被变形的数组, 然后再以相同顺序放置到新数组中) <ul><li><code>C</code> 从最低的维度优先读取与写入数据, 即列优先</li><li><code>F</code> 从最高的维度优先读取与写入数据, 即行优先</li></ul></li></ul></li><li><code>np.expand_dims(a, axis)</code> 扩展数组维度, 建议仅在一维数组转换为二维向量时使用<br> 对于任意数组数据 <code>arr</code><ul><li><code>np.expand_dims(arr.flat, 0)</code> 可获得一个行向量</li><li><code>np.expand_dims(arr.flat, 1)</code> 可获得一个列向量</li></ul></li></ul><h3 id="数组排序" tabindex="-1"><a class="header-anchor" href="#数组排序" aria-hidden="true">#</a> 数组排序</h3><ul><li><code>np.sort(a[, axis])</code> 数组从小到大排序 <ul><li><code>a</code> 被排序的数组</li><li><code>axis</code> 被排列的维度<br> 默认沿最低的维度排序 (对各行内的元素分别排序)<br> 对于二维数组</li><li>取 <code>axis = 1</code> 按行排序 (将数组按行分割, 排列其中各个子行的元素)</li><li>取 <code>axis = 0</code> 按列排序 (将数组按列分割, 排列其中各个子行的元素)</li></ul></li><li><code>np.argsort(a[, axis])</code> 数组从小到大排序, 但结果中使用索引代替值 <ul><li>参数含义与 <code>np.sort</code> 相同</li><li>结果的索引为划分的子列 / 行中的索引, 例如 <code>arr[np.argsort(arr, 0)[m, 1], 1]</code> 可获取 <code>arr</code> 第 1 列中从小到大次序为 m 的元素</li></ul></li></ul><h3 id="数组元素筛选" tabindex="-1"><a class="header-anchor" href="#数组元素筛选" aria-hidden="true">#</a> 数组元素筛选</h3><ul><li><code>np.argmax / argmin(a)</code> 获取数组中最大值 / 最小值元素的索引 <ul><li>对于高维数组, 返回值为在使用 <code>arr.flat</code> 展开时的索引</li><li>对于一维数组, 返回值即单个索引</li></ul></li><li><code>np.where(b)</code> 根据布尔数组, 获取布尔数组中为 <code>True</code> 的元素对应的索引 <ul><li>返回值为一个 <code>n</code> 元素的元组, 其中的元素均为 <code>m</code> 元素的正数数组对象<br> 其中 <code>n</code> 即数组 <code>b</code> 的维数, <code>m</code> 为数组 <code>b</code> 中为 <code>True</code> 的元素个数</li><li>可配合<a href="#%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95">数组索引</a>得到类似布尔索引的效果</li></ul></li></ul><h3 id="数组统计" tabindex="-1"><a class="header-anchor" href="#数组统计" aria-hidden="true">#</a> 数组统计</h3>',56),f=o("<li><code>np.max / amin(a[, axis])</code> 获取数组的最大值 / 最小值 <ul><li><code>a</code> 被统计的数组</li><li><code>axis</code> 沿特定轴统计 (之后的统计函数类似)<br> 即遍历统计轴外的维度, 将统计轴上的极值存在数组的对应位置中<br> 默认为整个数组统计, 得到单个结果<br> 例如 <ul><li>对于二维数组 <code>axis = 0</code> 表明统计各列的极值</li><li>对于二维数组 <code>axis = 1</code> 表明统计各行的极值</li><li>对于三维数组 <code>axis = 0</code> 将分别统计得到一个矩阵, 该矩阵各个位置的元素为数组中所有矩阵在该位置上的最大元素</li></ul></li></ul></li><li><code>np.median(a[, axis])</code> 获取数组的中位数</li><li><code>np.median(a[, axis])</code> 获取数组的算数平均数</li><li><code>np.std(a[, axis])</code> 获取数组的标准差</li><li><code>np.var(a[, axis])</code> 获取数组的方差</li><li><code>np.ptp(a[, axis])</code> 获取数组的极差</li>",6),y=l("code",null,"np.corrcoef(x, y)",-1),_={href:"https://numpy.org/doc/stable/reference/generated/numpy.corrcoef.html",target:"_blank",rel:"noopener noreferrer"},E=o('<h2 id="数学函数应用" tabindex="-1"><a class="header-anchor" href="#数学函数应用" aria-hidden="true">#</a> 数学函数应用</h2><h3 id="基础应用" tabindex="-1"><a class="header-anchor" href="#基础应用" aria-hidden="true">#</a> 基础应用</h3><ul><li><code>np.e / np.pi / np.inf</code> 常量, 表示自然对数的底数, 圆周率, 无穷大</li><li><code>np.cos / sin / tan(a)</code> 三角函数, 可传入单个数值或数组, 单位为弧度</li><li><code>np.exp / sqrt / square / abs(a)</code> 常用的指数, 开方, 平方, 绝对值函数</li><li><code>np.log / log2 / log10(a)</code> 自然对数, 以 2 为底的对数, 以 10 为底的对数函数</li><li><code>np.rad2deg / deg2rad(a)</code> 角度制与弧度制转换</li><li><code>np.around(a, decimals = 0)</code> 四舍五入 <ul><li><code>a</code> 四舍五入的数值或数组</li><li><code>decimals</code> 舍入到小数点后的位置, 如果传入负数, 将舍入到小数点前</li></ul></li><li><code>np.arctan2(x, y)</code> 四象限反正切, 分别对应 X, Y 坐标, 返回值单位为弧度</li><li><code>np.power(x, y)</code> x 的 y 次幂</li></ul><h3 id="多项式" tabindex="-1"><a class="header-anchor" href="#多项式" aria-hidden="true">#</a> 多项式</h3>',4),B={href:"https://numpy.org/doc/stable/reference/routines.polynomials.poly1d.html",target:"_blank",rel:"noopener noreferrer"},g=o('<ul><li><code>np.roots()</code> 多项式求解</li><li><code>np.polyfit()</code> 多项式拟合</li><li><code>np.polymul()</code> 多项式相乘</li><li><code>np.polydiv()</code> 多项式相除</li><li><code>np.polyval()</code> 多项式求值</li></ul><h3 id="线性代数" tabindex="-1"><a class="header-anchor" href="#线性代数" aria-hidden="true">#</a> 线性代数</h3><p>注意在线性代数中, 必须确保所有参与运算的数组对象都是二维的<br> 一维数组需要通过<a href="#%E6%95%B0%E7%BB%84%E5%8F%98%E5%9E%8B">数组变型</a>转换为向量</p>',3),k={href:"https://numpy.org/doc/stable/reference/routines.linalg.html",target:"_blank",rel:"noopener noreferrer"},A=l("ul",null,[l("li",null,[l("code",null,"mat.T"),e(" 获取向量 / 矩阵的转置")]),l("li",null,[l("code",null,"np.dot(a, b)"),e(" 计算两向量的点乘")]),l("li",null,[l("code",null,"np.cross(a, b)"),e(" 计算两向量的交叉积, 注意 "),l("code",null,"a, b"),e(" 需要为行向量, 且结果也是行向量")]),l("li",null,[l("code",null,"a @ b"),e(" 矩阵乘法 (注意 Numpy 中的矩阵乘法需要使用此符号) "),l("ul",null,[l("li",null,[e("如果 "),l("code",null,"a, b"),e(" 中有一个矩阵与一个一维数组 (或两个一维数组), 将自动确定一维数组的形状 (左乘行向量, 右乘列向量)")])])]),l("li",null,[l("code",null,"np.linalg.norm(x, ord)"),e(" 计算矩阵或向量的范数 "),l("ul",null,[l("li",null,[l("code",null,"x"),e(" 用于计算的矩阵或向量")]),l("li",null,[l("code",null,"ord"),e(" 范数类型 (对于向量默认为 "),l("code",null,"2"),e(", 对于矩阵默认为 "),l("code",null,"fro"),e(") "),l("ul",null,[l("li",null,[e("数字表示 p 范数, 可以是 "),l("code",null,"np.inf")]),l("li",null,[l("code",null,"fro"),e(" 表示 F 范数")])])])])]),l("li",null,[l("code",null,"np.linalg.svd(a, compute_uv=True)"),e(" 奇异值分解 "),l("ul",null,[l("li",null,[l("code",null,"a"),e(" 用于计算的数组")]),l("li",null,[l("code",null,"compute_uv"),e(" 是否计算矩阵 "),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"U"),l("mo",{separator:"true"},","),l("mi",null,"V")]),l("annotation",{encoding:"application/x-tex"},"U, V")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8778em","vertical-align":"-0.1944em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"U"),l("span",{class:"mpunct"},","),l("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V")])])])]),l("li",null,[e("返回元组 "),l("code",null,"(U, S, Vh)"),l("ul",null,[l("li",null,[l("code",null,"U, Vh"),e(" 奇异值分解中的正交矩阵 ("),l("code",null,"compute_uv=True"),e(" 时返回)")]),l("li",null,[l("code",null,"S"),e(" 由奇异值组成的向量")])])])])])],-1),N=o('<h2 id="高级应用" tabindex="-1"><a class="header-anchor" href="#高级应用" aria-hidden="true">#</a> 高级应用</h2><h3 id="数组间赋值与拷贝" tabindex="-1"><a class="header-anchor" href="#数组间赋值与拷贝" aria-hidden="true">#</a> 数组间赋值与拷贝</h3><ul><li>默认情况下, 数组对象间的直接赋值为浅复制, 因此赋值 <code>arr = b</code> 后, 修改数组 <code>arr</code> 时数组 <code>b</code> 也将同时被修改</li><li>除了直接赋值, 数组<a href="#%E7%B4%A2%E5%BC%95%E4%BA%A4%E4%BA%92">索引</a>得到的子数组, 以及<a href="#%E6%95%B0%E7%BB%84%E5%8F%98%E5%9E%8B">数组通过 flat, T 等映射</a>赋值给新数组也是浅复制</li><li>将数组传递给函数也是浅复制, 因此修改作为参数的数组对象, 原始数组对象也将改变</li><li>对于<a href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C">大部分数组操作</a>与<a href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8">数学函数应用</a>, 返回值都是与新的数组</li></ul><p>因此, 如果希望进行深拷贝避免连带性的修改, 应当使用数组对象的方法 <code>arr.copy()</code>, 创建一个数组对象的深拷贝</p><h3 id="数据导入与导出" tabindex="-1"><a class="header-anchor" href="#数据导入与导出" aria-hidden="true">#</a> 数据导入与导出</h3>',5),w=l("code",null,"np.save(file, arr)",-1),v=l("code",null,"file",-1),T=l("ul",null,[l("li",null,[e("传入文件名时, 不需要指定后缀, 将自动保存为具有后缀 "),l("code",null,".npy"),e(" 的文件")]),l("li",null,[e("传入文件对象时, 应使用二进制写入即 "),l("code",null,"rb"),e(" 模式")])],-1),C=l("li",null,[l("code",null,"arr"),e(" 导出的 Numpy 数组")],-1),z=l("code",null,"np.savez(file, *arrs, **kwarrs)",-1),D=l("code",null,"file",-1),P=l("ul",null,[l("li",null,[e("传入文件名时, 不需要指定后缀, 将自动保存为具有后缀 "),l("code",null,".npz"),e(" 的文件")]),l("li",null,[e("传入文件对象时, 应使用二进制写入即 "),l("code",null,"rb"),e(" 模式")])],-1),j=l("li",null,[l("code",null,"*arrs, **kwarrs"),e(" 导出的多个 Numpy 数组 "),l("ul",null,[l("li",null,[e("按位置传入时将命名为 "),l("code",null,"arr_n")]),l("li",null,"按关节字传入时将根据关键字命名")])],-1),F=l("li",null,[e("类似的还有 "),l("code",null,"np.savez_compressed"),e(" 该函数将同时压缩数组")],-1),V=l("code",null,"np.load(file)",-1),L=l("code",null,".npy",-1),M=l("code",null,".npz",-1),U=l("code",null,"file",-1),q=l("ul",null,[l("li",null,"传入文件名时, 需要给出带后缀的完整文件名"),l("li",null,[e("传入文件对象时, 应使用二进制读取即 "),l("code",null,"wb"),e(" 模式")])],-1),S=l("li",null,[e("读取 "),l("code",null,".npy"),e(" 文件时, 将返回一个 Numpy 数组")],-1),I=l("li",null,[e("读取 "),l("code",null,".npz"),e(" 文件时, 将返回一个字典, 字典的索引即保存时的数组名称, 值即对应的 Numpy 数组")],-1);function R(X,Y){const c=n("ExternalLinkIcon"),a=n("RouterLink");return u(),t("div",null,[h,l("blockquote",null,[l("p",null,[e("参考教程 "),l("a",p,[e("https://numpy.org/doc/stable/user/basics.creation.html"),d(c)])])]),m,b,x,l("ul",null,[f,l("li",null,[y,e(" 获取数组的相关系数, 参考 "),l("a",_,[e("https://numpy.org/doc/stable/reference/generated/numpy.corrcoef.html"),d(c)])])]),E,l("p",null,[e("关于多项式函数的详细说明参考 "),l("a",B,[e("https://numpy.org/doc/stable/reference/routines.polynomials.poly1d.html"),d(c)])]),g,l("p",null,[e("对于矩阵分解等更多函数, 见 "),l("a",k,[e("https://numpy.org/doc/stable/reference/routines.linalg.html"),d(c)])]),A,N,l("ul",null,[l("li",null,[w,e(" 以二进制形式导出单个 Numpy 数组 "),l("ul",null,[l("li",null,[v,e(" 文件名或"),d(a,{to:"/coding/py/base/module.html#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"},{default:i(()=>[e("文件对象")]),_:1}),T]),C])]),l("li",null,[z,e(" 以二进制形式导出多个 Numpy 数组 "),l("ul",null,[l("li",null,[D,e(" 文件名或"),d(a,{to:"/coding/py/base/module.html#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"},{default:i(()=>[e("文件对象")]),_:1}),P]),j,F])]),l("li",null,[V,e(" 导入 Numpy 数组文件 "),L,e(" 或 "),M,l("ul",null,[l("li",null,[U,e(" 文件名或"),d(a,{to:"/coding/py/base/module.html#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"},{default:i(()=>[e("文件对象")]),_:1}),q]),S,I])])])])}const J=r(s,[["render",R],["__file","numpy.html.vue"]]);export{J as default};
