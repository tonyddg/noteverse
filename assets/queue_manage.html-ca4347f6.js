import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as l,c as t,f as u,b as e,d as a,a as c,e as d}from"./app-8c5ce49e.js";const r={},o=e("h1",{id:"队列管理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#队列管理","aria-hidden":"true"},"#"),a(" 队列管理")],-1),p=d(`<h2 id="全局变量和弊端" tabindex="-1"><a class="header-anchor" href="#全局变量和弊端" aria-hidden="true">#</a> 全局变量和弊端</h2><ul><li>使用全局变量将导致线程不安全, 一种解决这个问题的方案就是采用队列</li><li>队列提供了一种任务间或者任务和中断间的通讯机制</li></ul><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h2><ul><li>队列是先进先出 FIFO (First In First Out), 先进先出表示的是先写入的数据会先被读取</li><li>队列中的数据必须是相同类型的, 可以是基本类型也可以是结构体</li><li>FreeRTOS 采用是复制队列的实现方式, 即写入队列的数据每个字节都被完整复制到队列, 不通过引用方式保存</li><li>如果使用指针管理队列, 可能指针的资源已被销毁, 但留在队列中导致错误</li><li>当一个任务试图从队列读取数据的时候, 它可以设置一个阻塞时间 (block time), 这是当队列数据为空时, 任务处于阻塞状态的时间, 当有数据在队列或者到达阻塞时间的时候，任务都会进入就绪状态</li><li><mark>将队列定义为全局变量, 各个任务通过队列传输数据</mark></li></ul><h2 id="队列操作方法" tabindex="-1"><a class="header-anchor" href="#队列操作方法" aria-hidden="true">#</a> 队列操作方法</h2><h3 id="创建队列" tabindex="-1"><a class="header-anchor" href="#创建队列" aria-hidden="true">#</a> 创建队列</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>QueueHandle_t <span class="token function">xQueueCreate</span><span class="token punctuation">(</span>
    UBaseType_t uxQueueLength<span class="token punctuation">,</span> UBaseType_t uxItemSize<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>uxQueueLength 队列包含数据的最大长度</li><li>uxItemSize 每个数据占用的字节大小</li><li>函数返回值 <ul><li>QueueHandle_t 句柄类型, 表示的是对所创建队列的一个引用句柄</li><li>没有足够的空间时, 返回 NULL</li></ul></li></ul><h3 id="发送数据" tabindex="-1"><a class="header-anchor" href="#发送数据" aria-hidden="true">#</a> 发送数据</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>BaseType_t <span class="token function">xQueueSend</span><span class="token punctuation">(</span> 
    QueueHandle_t xQueue<span class="token punctuation">,</span> 
    <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span>
    TickType_t xTicksToWait <span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果要在中断程序调用的话需要使用 xQueueSendFromISR() 函数</li><li>xQueue 队列的句柄, 来自于 xQueueCreate() 的返回值</li><li>pvItemToQueue 所发送数据的引用, 然后这些数据会被复制到队列中</li><li>xTicksToWait 队列如果满时发送任务的阻塞时间, 单位为时间片节拍数, 如果设置为 portMAX_DELAY 的话任务将永远等待下去</li><li>返回值 发送数据成功时返回 pdPASS, 失败时返回 errQUEUE_FULL</li></ul><h3 id="读取数据" tabindex="-1"><a class="header-anchor" href="#读取数据" aria-hidden="true">#</a> 读取数据</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>BaseType_t <span class="token function">xQueueReceive</span><span class="token punctuation">(</span> 
    QueueHandle_t xQueue<span class="token punctuation">,</span> 
    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">const</span> pvBuffer<span class="token punctuation">,</span>
    TickType_t xTicksToWait <span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>xQueue 队列的具柄</li><li>pvBuffer 指向内存空间的一个引用, 读取的数据会被复制到这片内存</li><li>xTicksToWait 队列如果空时接送任务的阻塞时间</li><li>返回值 发送数据成功时返回 pdPASS, 失败时返回 errQUEUE_FULL</li></ul><h3 id="获取队列中的数据" tabindex="-1"><a class="header-anchor" href="#获取队列中的数据" aria-hidden="true">#</a> 获取队列中的数据</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>UBaseType_t <span class="token function">uxQueueMessagesWaiting</span><span class="token punctuation">(</span> 
    QueueHandle_t xQueue <span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cmsis-rtos-的封装" tabindex="-1"><a class="header-anchor" href="#cmsis-rtos-的封装" aria-hidden="true">#</a> CMSIS RTOS 的封装</h3>`,17),h=e("li",null,"创建队列 osMessageQueueNew",-1),m=e("li",null,[a("获取信息 "),e("ul",null,[e("li",null,"osMessageQueueGet"),e("li",null,"当 timeout 为 0 时允许从中断函数调用")])],-1),v=e("li",null,[a("插入信息 "),e("ul",null,[e("li",null,"osMessageQueuePut"),e("li",null,"当 timeout 为 0 时允许从中断函数调用")])],-1),_={href:"https://blog.csdn.net/RootCode/article/details/106801936",target:"_blank",rel:"noopener noreferrer"},k=e("h2",{id:"实例",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#实例","aria-hidden":"true"},"#"),a(" 实例")],-1),x=e("ol",null,[e("li",null,"使用任务 1 检测扫描键盘输入, 使用任务 2 将键盘输入转为串口输出"),e("li",null,"键盘输入共有四种信息, 其中键盘持续按下与持续松开的信息占主要"),e("li",null,"如果把每次信息均插入队列, 这要求处理部分的处理速度更快, 否则队列将爆满"),e("li",null,"由于按下与松开的信息并不是主要信息, 并且, 因此可以忽略, 只发送点击与释放的信息"),e("li",null,"忽略这些信息后, 即保证了处理部分的速度可以慢于获取部分, 也避免了对无用信息的处理"),e("li",null,"为了保证能够快速处理任务, 因此可以使用永久阻塞等待消息 (osWaitForever), 减少调度的消耗")],-1);function b(f,g){const n=i("ExternalLinkIcon");return l(),t("div",null,[o,u(" ![](./src/queue_example.webp) "),p,e("ol",null,[h,m,v,e("li",null,[e("a",_,[a("其他参考"),c(n)])])]),k,x])}const S=s(r,[["render",b],["__file","queue_manage.html.vue"]]);export{S as default};
