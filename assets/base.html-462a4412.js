import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as r,e as t}from"./app-8c5ce49e.js";const i={},d=t(`<h3 id="use-strict" tabindex="-1"><a class="header-anchor" href="#use-strict" aria-hidden="true">#</a> “use strict”</h3><p>这个指令看上去像一个字符串 &quot;use strict&quot; 或者 &#39;use strict&#39;。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。</p><h3 id="变量" tabindex="-1"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h3><p>var — 老旧的变量声明方式。一般情况下，我们不会再使用它。</p><h4 id="额外声明一个变量" tabindex="-1"><a class="header-anchor" href="#额外声明一个变量" aria-hidden="true">#</a> 额外声明一个变量</h4><p>额外声明一个变量绝对是利大于弊的。 现代的 JavaScript 压缩器和浏览器都能够很好地对代码进行优化，所以不会产生性能问题。为不同的值使用不同的变量可以帮助引擎对代码进行优化。</p><h4 id="未采用-use-strict-下的赋值" tabindex="-1"><a class="header-anchor" href="#未采用-use-strict-下的赋值" aria-hidden="true">#</a> 未采用 use strict 下的赋值</h4><p>一般，我们需要在使用一个变量前定义它。但是在早期，我们可以不使用 let 进行变量声明，而可以简单地通过赋值来创建一个变量。现在如果我们不在脚本中使用 use strict 声明启用严格模式，这仍然可以正常工作，这是为了保持对旧脚本的兼容。</p><h3 id="变量-1" tabindex="-1"><a class="header-anchor" href="#变量-1" aria-hidden="true">#</a> 变量</h3><p>bigint 用于任意长度的整数。 我们可以通过 typeof 运算符查看存储在变量中的数据类型。</p><h4 id="typeof" tabindex="-1"><a class="header-anchor" href="#typeof" aria-hidden="true">#</a> typeof</h4><p>通常用作 typeof x，但 typeof(x) 也可行。 typeof null 的结果为 &quot;object&quot;。这是官方承认的 typeof 的错误。</p><h3 id="交互" tabindex="-1"><a class="header-anchor" href="#交互" aria-hidden="true">#</a> 交互</h3><h4 id="alert" tabindex="-1"><a class="header-anchor" href="#alert" aria-hidden="true">#</a> alert</h4><p>弹出的这个带有信息的小窗口被称为 模态窗。“modal” 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。</p><h4 id="prompt" tabindex="-1"><a class="header-anchor" href="#prompt" aria-hidden="true">#</a> prompt</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>result = prompt(title, [default]);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。</p><h4 id="confirm" tabindex="-1"><a class="header-anchor" href="#confirm" aria-hidden="true">#</a> confirm</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>result = confirm(question);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>confirm 函数显示一个带有 question 以及确定和取消两个按钮的模态窗口。 点击确定返回 true，点击取消返回 false。</p><h3 id="类型转换" tabindex="-1"><a class="header-anchor" href="#类型转换" aria-hidden="true">#</a> 类型转换</h3><h4 id="字符串转换" tabindex="-1"><a class="header-anchor" href="#字符串转换" aria-hidden="true">#</a> 字符串转换</h4><p>当我们需要一个字符串形式的值时，就会进行字符串转换。 我们也可以显式地调用 String(value) 来将 value 转换为字符串类型 字符串转换最明显。false 变成 &quot;false&quot;，null 变成 &quot;null&quot; 等。</p><h4 id="数字型转换" tabindex="-1"><a class="header-anchor" href="#数字型转换" aria-hidden="true">#</a> 数字型转换</h4><p>在算术函数和表达式中，会自动进行 number 类型转换。 我们也可以使用 Number(value) 显式地将这个 value 转换为 number 类型。 如果该字符串不是一个有效的数字，转换的结果会是 NaN</p><h5 id="number-类型转换规则" tabindex="-1"><a class="header-anchor" href="#number-类型转换规则" aria-hidden="true">#</a> number 类型转换规则</h5><p>undefined NaN null 0 true 和 false 1 and 0 string 去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 0。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 NaN。</p><h4 id="布尔型转换" tabindex="-1"><a class="header-anchor" href="#布尔型转换" aria-hidden="true">#</a> 布尔型转换</h4><p>直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false。 其他值变成 true。 包含 0 的字符串 &quot;0&quot; 是 true</p>`,30),n=[d];function h(s,u){return a(),r("div",null,n)}const l=e(i,[["render",h],["__file","base.html.vue"]]);export{l as default};
