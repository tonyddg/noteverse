import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as i,c as p,b as n,d as a,a as s,w as d,e as o}from"./app-8c5ce49e.js";const u={},r=n("h1",{id:"python-语法总结",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#python-语法总结","aria-hidden":"true"},"#"),a(" Python 语法总结")],-1),k={href:"https://docs.python.org/zh-cn/3/tutorial/index.html",target:"_blank",rel:"noopener noreferrer"},h=o(`<h2 id="基础语法" tabindex="-1"><a class="header-anchor" href="#基础语法" aria-hidden="true">#</a> 基础语法</h2><h3 id="基本语法" tabindex="-1"><a class="header-anchor" href="#基本语法" aria-hidden="true">#</a> 基本语法</h3><h4 id="环境说明" tabindex="-1"><a class="header-anchor" href="#环境说明" aria-hidden="true">#</a> 环境说明</h4><ul><li>Python 脚本需要在第一行使用 <code>#!&lt;解释器路径&gt;</code> 声明脚本使用的解释器 (来自 Linux 系统的规范), 通常使用 <ul><li><code>#!/usr/bin/python</code> 使用安装在默认位置的 Python</li><li><code>#!/usr/bin/env python</code> 在环境变量中查找 Python</li></ul></li><li>Python 脚本需要在第二行声明脚本文件所使用的编码类型, 通常使用 utf-8, 因此使用如下方式声明 <ul><li><code># -*- coding: UTF-8 -*-</code></li></ul></li></ul><h4 id="行和缩进" tabindex="-1"><a class="header-anchor" href="#行和缩进" aria-hidden="true">#</a> 行和缩进</h4><ul><li>Python 中通过缩进区分语句的层级, 最低层级的语句不需要缩进</li><li>缩进可以是单个制表符, 两个空格或四个空格, 但在一个 Python 脚本中需要统一</li><li>定义<a href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8">容器</a>时 <code>[]</code>, <code>{}</code> 或 <code>()</code> 内的内容可以任意换行且没有缩进要求</li><li>可以使用反斜杠 <code>\\</code> 将一行的语句分为多行显示, 第二行没有缩进要求</li><li>同一行中使用多条语句时, 语句之间使用分号 <code>;</code> 分割</li></ul><h4 id="注释" tabindex="-1"><a class="header-anchor" href="#注释" aria-hidden="true">#</a> 注释</h4><ul><li>python中单行注释采用 <code>#</code> 开头</li><li>python 中多行注释使用三个单引号 <code>&#39;&#39;&#39;</code> 或三个双引号 <code>&quot;&quot;&quot;</code> 包裹注释内容</li></ul><h4 id="变量定义" tabindex="-1"><a class="header-anchor" href="#变量定义" aria-hidden="true">#</a> 变量定义</h4><ul><li>通过 <code>=</code> 运算符未一个不存在的变量赋值时, 将自动创建变量</li><li>使用变量前应当通过赋值的方式声明, 如果不能确定可以赋 <code>None</code></li><li>当变量名由大写字母与下划线时, 表示常量</li></ul><h3 id="运算符" tabindex="-1"><a class="header-anchor" href="#运算符" aria-hidden="true">#</a> 运算符</h3><h4 id="算数运算" tabindex="-1"><a class="header-anchor" href="#算数运算" aria-hidden="true">#</a> 算数运算</h4><table><thead><tr><th>符号</th><th>含义</th><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法运算</td><td><code>*</code></td><td>乘法运算</td></tr><tr><td><code>-</code></td><td>减法运算</td><td><code>/</code></td><td>除法运算</td></tr><tr><td><code>%</code></td><td>求余运算</td><td><code>**</code></td><td>幂运算</td></tr><tr><td><code>//</code></td><td>整除运算, 向 0 取整</td><td></td><td></td></tr></tbody></table><h4 id="赋值运算符" tabindex="-1"><a class="header-anchor" href="#赋值运算符" aria-hidden="true">#</a> 赋值运算符</h4><table><thead><tr><th>符号</th><th>含义</th><th>解释</th></tr></thead><tbody><tr><td><code>=</code></td><td>赋值</td><td>通过赋值运算即可创建新的变量</td></tr><tr><td><code>+=</code></td><td>运算赋值</td><td>将右侧的值与被赋值变量运算后赋值, 可用任意<a href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97">算数运算符</a>替换 <code>+</code></td></tr><tr><td><code>:=</code></td><td>海象赋值</td><td>赋值同时将右侧的值作为结果返回, 可用于简化代码, 例如 <code>(n := 5) &gt; 5</code></td></tr></tbody></table><h4 id="比较与逻辑运算" tabindex="-1"><a class="header-anchor" href="#比较与逻辑运算" aria-hidden="true">#</a> 比较与逻辑运算</h4><table><thead><tr><th>符号</th><th>含义</th><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td><td><code>!=</code></td><td>不等于</td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>and</code></td><td>逻辑与 (短路求值)</td><td><code>or</code></td><td>逻辑或 (短路求值)</td></tr><tr><td><code>not</code></td><td>逻辑非</td><td></td><td></td></tr></tbody></table><p><code>0</code>, 空字符串, <code>False</code> 表示逻辑假<br> 其余数值与字符串, <code>True</code> 表示逻辑真</p><h4 id="位运算" tabindex="-1"><a class="header-anchor" href="#位运算" aria-hidden="true">#</a> 位运算</h4><p>将参与运算的变量视为二进制<br> 最好仅用于整数</p><table><thead><tr><th>符号</th><th>含义</th><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td><code>|</code></td><td>按位或</td></tr><tr><td><code>^</code></td><td>按位异或</td><td><code>~</code></td><td>按位取反</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移运算符</td><td><code>&gt;&gt;</code></td><td>右移运算符</td></tr></tbody></table><h4 id="特殊运算符" tabindex="-1"><a class="header-anchor" href="#特殊运算符" aria-hidden="true">#</a> 特殊运算符</h4><table><thead><tr><th>符号</th><th>含义</th><th>解释</th></tr></thead><tbody><tr><td><code>is</code></td><td>身份运算符</td><td>判断两个变量是否引用同一个对象</td></tr><tr><td><code>in</code></td><td>成员运算符</td><td>运算 <code>b in a</code> 中, <code>a</code> 为一个字符串或元组等容器, 当容器中有元素与 <code>b</code> 相同时, 返回 <code>True</code></td></tr></tbody></table><h3 id="流程控制" tabindex="-1"><a class="header-anchor" href="#流程控制" aria-hidden="true">#</a> 流程控制</h3><h4 id="if-条件语句" tabindex="-1"><a class="header-anchor" href="#if-条件语句" aria-hidden="true">#</a> if 条件语句</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">if</span> <span class="token operator">&lt;</span>条件<span class="token number">1</span><span class="token operator">&gt;</span> <span class="token punctuation">:</span>
    <span class="token operator">&lt;</span>语句<span class="token number">1</span><span class="token operator">&gt;</span>
<span class="token keyword">elif</span> <span class="token operator">&lt;</span>条件<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token punctuation">:</span>
    <span class="token operator">&lt;</span>语句<span class="token number">2</span><span class="token operator">&gt;</span>
<span class="token keyword">else</span><span class="token punctuation">:</span> 
    <span class="token operator">&lt;</span>语句<span class="token number">3</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>分支语句 <code>else</code> 与 <code>elif</code> 不是必须的</li><li>允许有任意个 <code>elif</code></li></ul><h4 id="match-条件匹配语句" tabindex="-1"><a class="header-anchor" href="#match-条件匹配语句" aria-hidden="true">#</a> match 条件匹配语句</h4><p>在 3.10 版本加入</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">match</span> <span class="token operator">&lt;</span>val<span class="token operator">&gt;</span><span class="token punctuation">:</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;</span>n1<span class="token operator">&gt;</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;</span>n2<span class="token operator">&gt;</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>val</code> 用于条件匹配的变量</li><li><code>n1, n2</code> 匹配表达式, 当匹配时, 将执行对应的语句 <ul><li>可以是单个值, 如数值, <a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB">枚举值</a>等</li><li>可以使用 <code>|</code> 连接多个值用于匹配</li><li>可以使用 <code>_</code> 表示与已有条件不匹配的情况</li><li>可以使用带未知量的元组, 如 <code>(x, 0)</code> (也可以使用 <code>[]</code>) <ul><li>当 <code>val</code> 为一个相同形状的列表或元组, 且匹配除了未知数以外位置的元素时, 匹配成功</li><li>匹配成功时未知量将提取对应位置的元素作为条件语句的临时变量</li><li>在末尾使用 <code>*rest</code> 可提取剩余的部分 (可以为空) 到 <code>rest</code>, 且不再要求形状匹配 (也可使用 <code>*_</code> 但不提取剩余部分)</li><li>可在后接 <code>if</code> 规定提取变量的条件, 如 <code>case (x, y) if x == y:</code></li></ul></li><li>可以使用带值的字典, 如 <code>{&quot;X&quot; : x, &quot;Y&quot; : 0}</code><ul><li>匹配与提取类似元组, 但对于 <code>val</code> 额外的键没有匹配要求</li><li>使用 <code>**rest</code> 可提取剩余键值对到 <code>rest</code> 中</li></ul></li></ul></li><li>不同于 C++, 不需要使用 <code>break</code> 退出</li></ul><h4 id="for-循环语句" tabindex="-1"><a class="header-anchor" href="#for-循环语句" aria-hidden="true">#</a> for 循环语句</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">for</span> <span class="token operator">&lt;</span>it<span class="token operator">&gt;</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>a<span class="token operator">&gt;</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>要求 <code>a</code> 为一个可迭代对象, 如字典, 列表等, 可参见<a href="#%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3">容器迭代</a></li><li>每次循环都将从 <code>a</code> 中迭代一个值并赋给 <code>it</code>, 当 <code>a</code> 被迭代完时退出循环</li><li>当迭代变量为序列如元组时可以有多个迭代变量, 赋值规则类似<a href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列解包</a></li><li>可使用 <a href="#%E7%94%9F%E6%88%90%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97">range</a> 函数构造迭代对象, <code>it : range(n)</code> 表示循环 <code>n</code> 次</li></ul><h4 id="while-循环语句" tabindex="-1"><a class="header-anchor" href="#while-循环语句" aria-hidden="true">#</a> while 循环语句</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">while</span> <span class="token operator">&lt;</span>exp<span class="token operator">&gt;</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>exp</code> 为一个得到逻辑表达式, 当表达式为真将运行循环</li><li>循环开始前先判断 <code>exp</code>, 当循环结束后再次判断, 直到 <code>exp</code> 结果为 <code>False</code> 退出循环</li></ul><h4 id="控制语句" tabindex="-1"><a class="header-anchor" href="#控制语句" aria-hidden="true">#</a> 控制语句</h4><ul><li><code>break</code> 跳出当前循环 (用于循环语句)</li><li><code>continue</code> 结束当前循环进入下一次循环 (用于循环语句)</li><li><code>pass</code> 表示空过程, 可用于函数, 分支, 循环语句中占位等待编写</li></ul><h3 id="实用函数与操作" tabindex="-1"><a class="header-anchor" href="#实用函数与操作" aria-hidden="true">#</a> 实用函数与操作</h3><h4 id="生成整数序列" tabindex="-1"><a class="header-anchor" href="#生成整数序列" aria-hidden="true">#</a> 生成整数序列</h4><p><code>range([start, ]stop, step = 1)</code></p><ul><li><code>start</code> 序列开始, 包含在序列中</li><li><code>stop</code> 序列末尾, 不包含在序列中</li><li><code>step</code> 数列步长</li></ul><p>要求</p><ul><li>传入的参数必须为整数</li><li>通常配合 <a href="#for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">for 循环语句</a>使用</li></ul><h4 id="打印对象到控制台" tabindex="-1"><a class="header-anchor" href="#打印对象到控制台" aria-hidden="true">#</a> 打印对象到控制台</h4><p><code>print(*args)</code></p><ul><li><code>args</code> 将尝试将所有参数转换为字符串, 然后依次打印 (各个参数间以空格分割)</li></ul><p>注意</p><ul><li>如果希望格式化可参见<a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2">格式化字符串</a></li></ul><h4 id="获取控制台输入" tabindex="-1"><a class="header-anchor" href="#获取控制台输入" aria-hidden="true">#</a> 获取控制台输入</h4><p><code>input([s])</code></p><ul><li><code>s</code> 用于接收输入的提示字符</li></ul><p>注意</p><ul><li>默认接收到的均为字符串, 如果希望转换为数值, 则需要类型转换, 如 <code>n = float(input())</code></li><li>可以接收并解析<a href="#%E6%8E%A8%E5%AF%BC%E5%BC%8F">推导式</a></li></ul><h4 id="获取对象的长度" tabindex="-1"><a class="header-anchor" href="#获取对象的长度" aria-hidden="true">#</a> 获取对象的长度</h4><p><code>len(x)</code></p><ul><li><code>x</code> 可以是任意的<a href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li></ul><p>该方法时获取任意类型长度的通用一般方法</p><h4 id="删除变量与列表" tabindex="-1"><a class="header-anchor" href="#删除变量与列表" aria-hidden="true">#</a> 删除变量与列表</h4><p><code>del x</code></p><ul><li>当 <code>x</code> 为一个变量时, 将删除该变量</li><li>当 <code>x</code> 为带索引的容器时, 将删除该元素</li></ul><h4 id="变量类型判断" tabindex="-1"><a class="header-anchor" href="#变量类型判断" aria-hidden="true">#</a> 变量类型判断</h4><p><code>isinstance(x, type)</code> 判断变量 <code>x</code> 是否是类 <code>type</code> 的实例 (即判断类型)</p><ul><li><code>x</code> 变量名称</li><li><code>type</code> 类型名称, 可参考<a href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8">类型与容器</a>中的类型名称</li></ul><h2 id="类型与容器" tabindex="-1"><a class="header-anchor" href="#类型与容器" aria-hidden="true">#</a> 类型与容器</h2><p>Python 主要有以下基本内置类型</p><ul><li>Numbers (数字) <ul><li>int (有符号整型)</li><li>float (实数)</li><li>complex (复数) 使用 1j 表示虚数单位</li><li>bool (布尔)</li></ul></li><li>str (字符串)</li><li>list (列表)</li><li>tuple (元组)</li><li>dict (字典)</li><li>set (集合)</li><li>None (无类型)</li></ul><p>Python 中一切变量皆为对象, 一切类型皆为类, 因此使用这些类型对应名称的函数即对应的构造函数, 将其他参数传入构造函数 Python 将尝试进行变量转换, 如 <code>int(x)</code> 将尝试将 <code>x</code> 转换为整数类</p><h3 id="数值类型" tabindex="-1"><a class="header-anchor" href="#数值类型" aria-hidden="true">#</a> 数值类型</h3><ul><li>对于实数 <code>float</code>, 除了小数点加数字, 还可使用以下方式表示特殊实数 <ul><li><code>inf</code> 或 <code>Infinity</code> 表示正无穷</li><li><code>nan</code> 表示非数值</li><li><code>E/e</code> 表示 <code>*10^</code>, 如 <code>1e-2</code> 表示 <code>0.01</code></li></ul></li><li>对于复数 <code>complex</code><ul><li>可使用 <code>complex(real = 0, img = 0)</code> 构造</li><li>使用 1j 表示虚数单位</li><li>在将字符串转为复数时, 如 <code>a+b1j</code> 其中的加号不能有空格</li></ul></li><li>对于布尔类型 <code>bool</code><ul><li>使用 <code>True</code> 表示真</li><li>使用 <code>False</code> 表示假</li></ul></li></ul><h3 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h3><h4 id="字符串表示" tabindex="-1"><a class="header-anchor" href="#字符串表示" aria-hidden="true">#</a> 字符串表示</h4><ul><li>普通的字符串可使用成对的 <code>&quot;</code> 或 <code>&#39;</code> 包含表示</li><li>使用反斜杠 <code>\\</code> 可用于转义, 如 <code>\\n</code> 表示换行, <code>\\&quot;</code> 表示字符串中的 <code>&quot;</code></li><li>使用前缀 <code>r</code> 表示不进行转义, 通常用于表示正则表达式</li><li>使用前缀 <code>u</code> 表示 Unicode 保存字符串, 默认使用 <code>utf-8</code></li><li>表示多行字符串语法如下</li><li>使用单独一行的 <code>&quot;&quot;&quot;\\</code> 开始, <code>&quot;&quot;&quot;</code> 结尾, 表示多行字符串</li></ul><h4 id="字符串常用操作" tabindex="-1"><a class="header-anchor" href="#字符串常用操作" aria-hidden="true">#</a> 字符串常用操作</h4><ul><li>整数 <code>a</code> 与字符串 <code>s</code> 的乘法运算将重复字符串 <code>s</code> 共 <code>a</code> 次</li><li>字符串之间的加法运算能拼接两个字符串</li><li>使用 <code>[]</code> 运算符可索引字符串, 使用方法见<a href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列类型</a>, 注意字符串索引后不可修改</li><li>成员方法 <code>str.isnumeric()</code> 字符串中至少有一个字符且所有字符均为数值字符则返回 <code>True</code></li></ul><h4 id="格式化字符串" tabindex="-1"><a class="header-anchor" href="#格式化字符串" aria-hidden="true">#</a> 格式化字符串</h4><p>格式化字符串时, 字符串将根据给定的参数转换格式化符号, 得到实际字符串<br> 使用以下方式表示格式化字符串</p><ul><li><code>&quot;...&quot;.format(...)</code> 通过字符串的成员方法 <code>format</code> 传入参数, 格式化字符串</li><li><code>&quot;...&quot;%(...)</code> 将 <code>.format</code> 替换为 <code>%</code>, 效果与 <code>format</code> 相同</li><li><code>f&quot;...&quot;</code> 使用前缀 <code>f</code>, 此时将根据参数名称, 从当前环境中自动寻找变量</li></ul><p>格式化字符串的表示方法见附录<a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95">字符串格式化表示方法</a></p><h4 id="bytes-对象" tabindex="-1"><a class="header-anchor" href="#bytes-对象" aria-hidden="true">#</a> bytes 对象</h4><p>对于 Python 的字符串, 每个索引对应一个字符, 但根据编码不同字符的实际长度不同, 默认使用的是 utf-8 编码<br> 与字符串类似的, Python 还提供了 bytes 对象, 该对象更类似于 C++ 中的字符串, 每个索引对应一个字节即 <code>uint8</code> 类型的值<br> 通过该对象可用于实现访问二进制对象内存等操作</p><p>表示 bytes 对象时</p><ul><li>使用类字符串表示, 如 <code>b&quot;something&quot;</code>, 可使用 <code>&#39;</code>, <code>&quot;</code>, <code>&#39;&#39;&#39;</code> 包裹, 但内容只能是 ASCII 编码中已存在的字符</li><li>通过构造函数 <code>bytes(obj)</code> 传入一般对象时, 将复制对象的底层内存数据并以此创建 bytes 对象</li><li>通过函数 <code>bytes.fromhex(str)</code>, 传入一个由多个 16 进制数对, 数队间使用空格分隔组成的字符串, 将尝试通过该字符串给出的内容创建 bytes 对象</li></ul><p>一般类型与 bytes 对象之间转换</p>`,85),m=o("<li>对于字符串 <ul><li>字符串转为 bytes 对象<br> 字符串对象方法 <code>encode(encoding = &quot;utf -8&quot;)</code> 获取字符串内容在编码 <code>encoding</code> 下的二进制数据</li><li>bytes 对象转为字符串<br> bytes 对象方法 <code>decode(encoding = &quot;utf-8&quot;)</code> 获取二进制数据在编码 <code>encoding</code> 下的字符串内容</li></ul></li>",1),v={href:"https://docs.python.org/zh-cn/3/library/pickle.html",target:"_blank",rel:"noopener noreferrer"},b=o(`<h3 id="列表" tabindex="-1"><a class="header-anchor" href="#列表" aria-hidden="true">#</a> 列表</h3><ul><li>列表为一个有序的容器, 即<a href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列类型</a></li><li>列表的内容可以任意修改, 增加或删除</li><li>列表中可以有任意类型的内容, 但一般存放的是同一类型的元素</li></ul><h4 id="列表表示" tabindex="-1"><a class="header-anchor" href="#列表表示" aria-hidden="true">#</a> 列表表示</h4><ul><li>基本表示时, 使用 <code>[]</code> 包裹, 列表元素间使用 <code>,</code> 分隔, 如 <code>[1, 2, 3]</code></li><li>可使用<a href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F">列表推导式</a>生成列表</li><li>允许列表嵌套, 以此实现多维列表</li><li>可直接使用 <code>[]</code> 表示空列表</li></ul><h4 id="列表常用操作" tabindex="-1"><a class="header-anchor" href="#列表常用操作" aria-hidden="true">#</a> 列表常用操作</h4><ul><li><code>del list[n]</code> 使用 <a href="#%E5%88%A0%E9%99%A4%E5%8F%98%E9%87%8F%E4%B8%8E%E5%88%97%E8%A1%A8">del</a> 语句删除索引为 <code>n</code> 的元素</li><li><code>list.append(x)</code> 将变量 <code>x</code> 插入队列末尾 (注意对列不能访问不存在的元素, 因此一般使用此方法向队列插入元素)</li><li><code>list.pop()</code> 获取队列末尾元素, 并删除</li><li>由于列表属于序列类型, 索引方法见<a href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列类型</a></li></ul><h3 id="元组" tabindex="-1"><a class="header-anchor" href="#元组" aria-hidden="true">#</a> 元组</h3><ul><li>元组为一个有序的容器, 即<a href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列类型</a></li><li>元组的内容可以不可修改</li><li>元组一般用于存放多个不同内容的组合</li></ul><h4 id="元组常用操作" tabindex="-1"><a class="header-anchor" href="#元组常用操作" aria-hidden="true">#</a> 元组常用操作</h4><ul><li>元组的表示方式与<a href="#%E5%88%97%E8%A1%A8%E8%A1%A8%E7%A4%BA">列表表示</a>相同, 但使用 <code>()</code> 包裹内容, 也可省略</li><li>由于元组属于序列类型, 索引方法见<a href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列类型</a>, 注意元组索引后不可修改<br> 虽然不能覆盖元组中的元素, 但调用元组中元素的方法导致元素被改变是允许的</li><li><a href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列类型</a>的序列解包语法一般用于元组</li></ul><h3 id="字典" tabindex="-1"><a class="header-anchor" href="#字典" aria-hidden="true">#</a> 字典</h3><p>字典由一系列键值对组成<br> 键与值可以时任意类型, 但一般以字符串作为键类型<br> 键一旦创建后就不可修改, 但键对应的值可以修改</p><h4 id="字典表示" tabindex="-1"><a class="header-anchor" href="#字典表示" aria-hidden="true">#</a> 字典表示</h4><ul><li>基本表示时, 使用 <code>{}</code> 包裹, 键值对使用 <code>key : val</code> 表示, 使用 <code>,</code> 分隔, 如 <code>{&quot;x&quot; : 1, &quot;y&quot; : 2}</code></li><li>对于简单的键值对, 可使用构造函数 <code>dict(**kwargs)</code> 构造, 将函数参数的字符串作为键, 如 <code>dict(x = 1, y = 2)</code></li><li>可使用<a href="#%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F">字典推导式</a>生成列表</li><li>可直接使用 <code>{}</code> 表示空字典</li></ul><h4 id="字典常用操作" tabindex="-1"><a class="header-anchor" href="#字典常用操作" aria-hidden="true">#</a> 字典常用操作</h4><ul><li><code>del dict[n]</code> 使用 <a href="#%E5%88%A0%E9%99%A4%E5%8F%98%E9%87%8F%E4%B8%8E%E5%88%97%E8%A1%A8">del</a> 语句删除键为 <code>n</code> 的元素以及键</li><li><code>dict[n] = ...</code> 修改键 <code>n</code> 对应的值, 如果不存在将自动创建</li><li><code>a in dict</code> 对于字典的<a href="#%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6">成员运算符</a>, 当字典存在键 <code>a</code> 时返回 <code>True</code></li><li><code>dict.keys(), dict.valuse()</code> 获取字典的键或值用于<a href="#%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3">字典迭代</a>或<a href="#%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6">成员运算符 in</a>, 不是获取列表</li><li><code>dict1 | dict2</code> 合并两个字典, 键冲突时以 <code>dict2</code> 的值优先, 可使用此方法设置配置字典的默认值</li></ul><h3 id="容器的通用操作" tabindex="-1"><a class="header-anchor" href="#容器的通用操作" aria-hidden="true">#</a> 容器的通用操作</h3><p>对于容器类型, 有以下常用的通用操作</p><ul><li><code>in</code> <a href="#%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6">特殊运算符</a>, 用于判断变量是否在容器中</li><li><code>len(x)</code> <a href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%95%BF%E5%BA%A6">内置函数</a>, 可获取容器长度</li><li><a href="#%E6%8E%A8%E5%AF%BC%E5%BC%8F">推导式</a>, 可表示元素具有特殊规律的容器</li></ul><h4 id="序列类型" tabindex="-1"><a class="header-anchor" href="#序列类型" aria-hidden="true">#</a> 序列类型</h4><p>对于字符串, 列表, 元组均属于序列 (Sequence) 类型, 均可使用 <code>[]</code> 运算符可索引字符串</p><ul><li>以正整数 <code>a</code> 为索引时, 表示索引第 <code>a</code> 个字符, 从 0 开始</li><li>以负整数 <code>-a</code> 为索引时, 表示索引 <code>len - a</code>, <code>len</code> 为字符串长度, 如 <code>-1</code> 可索引最后一个字符</li><li>使用 <code>a:b</code> 可切片索引字符串, 获取索引 <code>a</code> 到 <code>b</code> 的子字符串 (不包括末尾 <code>b</code>)<br> 其中 <code>a,b</code> 可以省略</li><li>索引越界时将出错, 但切片索引能自动处理越界</li></ul><p>此外, 类似<a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">字符串的运算</a>, 序列均存在运算</p><ul><li><code>+</code> 用于拼接两个序列</li><li><code>*</code> 用于重复序列</li></ul><p>序列解包语法, 即可将序列中个元素分别赋给一系列变量</p><ul><li>例如 <code>a, b = (1, 2)</code> 可将序列的第 0, 1 个元素分别赋给 <code>a, b</code></li><li>解包时使用 <code>_</code> 表示空变量占位符, 此时该位置的列表元素将被丢弃</li><li>解包时使用 <code>*rest</code> 可将剩余位置存入变量 <code>rest</code> 中, 可以为空, 也可使用 <code>*_</code> 丢弃剩余元素</li><li>对于单元素序列, 通过例如 <code>a, = [1]</code> 的方法可以单独解包幅值其中的唯一一个元素</li></ul><h4 id="容器迭代" tabindex="-1"><a class="header-anchor" href="#容器迭代" aria-hidden="true">#</a> 容器迭代</h4><p>容器均为可迭代对象, 可使用 <a href="#for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">for 循环迭代</a></p><ul><li>迭代字典时, 将键值对作为元组 <code>(key, val)</code> 赋值给迭代变量<br> 如 <code>for k, v in dict:</code> 迭代变量 <code>k</code> 将接收字典的键, <code>v</code> 将接收对应的值</li><li>迭代字典时, 使用 <code>dict.keys() / dict.valuse()</code> 能分别迭代键与值</li><li>迭代序列时, 使用 <code>enumerate(list)</code> 将以元组 <code>(i, val)</code> 赋值给迭代变量 (<code>i</code> 为元素索引)<br> 如 <code>for i, t in enumerate(list):</code> 迭代变量 <code>i</code> 将接收索引, <code>t</code> 将接收对应的值</li><li>迭代可迭代对象时, 使用 <code>zip(list1, list2, ...)</code> 可拼接多个序列同时迭代 (长度必须相同), 每次迭代索引同一位置的各序列中的元素, 并合并为一个元组<br> 如 <code>for a, b in zip(list1, list2):</code> 迭代变量 <code>a</code> 将接收序列 <code>list1</code> 的元素, <code>b</code> 将接收序列 <code>list2</code> 的元素</li><li>迭代可迭代对象时, 使用 <code>set(list)</code> 可去除迭代对象中的重复元素 (本质为创建集合容器, 笔记中暂不介绍)</li></ul><h3 id="可变对象与不可变对象" tabindex="-1"><a class="header-anchor" href="#可变对象与不可变对象" aria-hidden="true">#</a> 可变对象与不可变对象</h3><p>在 Python 中, 类被分为两种类型, 即可变对象与不可变对象<br> 二者最基本的区别即</p><ul><li>不可变对象只能被访问其中的元素 (允许元素自身变化), 而不能修改, 如数值类型, 字符串与元组</li><li>可变对象能够访问与修改其中的元素, 如一般类, 列表与字典</li></ul><h4 id="引用与拷贝" tabindex="-1"><a class="header-anchor" href="#引用与拷贝" aria-hidden="true">#</a> 引用与拷贝</h4><ul><li>引用 <ul><li>引用仅发生在可变对象的传递中</li><li>引用即传递一个指向特定对象的指针</li><li>在引用过程中, 没有新对象被创建, 当引用变量被修改, 原始变量也将随之修改</li><li>例如定义列表 <code>a = [1, 2]</code>, 通过赋值 <code>b = a</code> 使 <code>b</code> 引用了该列表, 赋值 <code>b[0] = 1</code> 则变量 <code>a</code> 也将随之改变</li></ul></li><li>浅拷贝 <ul><li>浅拷贝发生在不可变对象的传递或可变对象的 <code>copy()</code> 方法创建</li><li>浅拷贝即是创建一个新的对象, 并将旧对象中的元素 (包括成员与容器) 直接赋给新对象<br> 因此当对象有成员或元素为一个可变对象, 则其浅拷贝的对应成员或元素也将指向该可变对象</li><li>例如定义元组 <code>a = ([1, 2], 3)</code>, 通过赋值 <code>b = a</code> 使 <code>b</code> 获得 <code>a</code> 的浅拷贝, 赋值 <code>b[0][0] = 1</code> 访问了元组中的列表, 而 <code>a[0]</code> 也保存了该列表的引用, 因此将随之修改</li></ul></li><li>深拷贝 <ul><li>深拷贝仅能通过 <code>copy</code> 模块的 <code>copy.deepcopy(x)</code> 方法实现</li><li>深拷贝时将递归对象的所有元素, 并创造一个与被复制对象以及底层引用完全相同但新的对象<br> 因此深拷贝可能导致极大的内存消耗, 不建议使用</li></ul></li></ul><h4 id="赋值与传递" tabindex="-1"><a class="header-anchor" href="#赋值与传递" aria-hidden="true">#</a> 赋值与传递</h4><p>在赋值与函数参数传递时</p><ul><li>可变对象总是仅传递自身的引用</li><li>不可变对象总是传递自身的浅拷贝</li></ul><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h2><h3 id="函数基本使用" tabindex="-1"><a class="header-anchor" href="#函数基本使用" aria-hidden="true">#</a> 函数基本使用</h3><p>使用如下方式定义函数</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">&#39;&#39;&#39;
&lt;docs&gt;    
&#39;&#39;&#39;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> val
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义函数时</p><ul><li>使用关键字 <code>def</code> 定义函数</li><li><code>fun</code> 函数名称, 推荐函数名称规则为小写字母单词 + 下划线组合<br> Python 中不允许存在同名的函数, 因此也无法直接定义重载函数, 也不推荐使用重载函数</li><li><code>a, b</code> 参数列表, 使用 <code>()</code> 包裹, 参数传递规则见<a href="#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">可变对象与不可变对象</a></li><li><code>docs</code> 为函数的说明文档, 使用独立一行的 <code>&#39;&#39;&#39;</code> 包裹, 可有多行并使用基础的 Markdown 语法, 也可省略</li><li><code>return</code> 函数返回值, 可通过返回<a href="#%E5%85%83%E7%BB%84">元组</a>与<a href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列类型</a>实现返回与接收多个值<br> 当没有返回值时, 函数返回 <code>None</code></li></ul><p>使用函数时</p><ul><li>通过 <code>函数名(参数1, 参数2, ...)</code> 的方式可调用函数, 即按位置传入参数</li><li>除了按位置传入参数, 还可以按参数名, 即按关键字传入参数, 此时可以不限定顺序<mark>但按关键字传入参数一定要在按位置传入参数之后</mark></li><li>当直接使用函数时, 则相当于一个可调用类型的变量</li></ul><h3 id="参数限定" tabindex="-1"><a class="header-anchor" href="#参数限定" aria-hidden="true">#</a> 参数限定</h3><h4 id="默认值参数" tabindex="-1"><a class="header-anchor" href="#默认值参数" aria-hidden="true">#</a> 默认值参数</h4><ul><li>在定义函数参数时, 使用 <code>&lt;参数名&gt; = &lt;默认值&gt;</code> 可确定函数参数的默认值, 当调用函数时, 若没有传入该参数, 则将使用默认值</li><li>可以使用任意值作为默认值, 但使用<a href="#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">可变对象</a>时, 由于默认值为一个指向该对象的引用, 且不会在函数调用后刷新, 因此默认值可能因函数调用而被修改, 不建议将可变对象作为函数的默认值</li><li>如果必须使用可变对象, 或其他代替默认值的场合可将 <code>None</code> 作为默认值, 并在函数运行前判断该参数是否为 <code>None</code>, 若为 <code>None</code> 则创建一个默认值并赋给该参数</li></ul><h4 id="变长参数与解包参数" tabindex="-1"><a class="header-anchor" href="#变长参数与解包参数" aria-hidden="true">#</a> 变长参数与解包参数</h4><ul><li>使用 <code>*args</code> 表示变长位置参数, 所有未被接收的位置参数都将保存到<a href="#%E5%85%83%E7%BB%84">元组</a> <code>args</code> 中</li><li>使用 <code>**kwargs</code> 表示变长关键字参数, 所有未被接收的关键字参数都将保存到<a href="#%E5%AD%97%E5%85%B8">字典</a> <code>**kwargs</code> 中</li><li>两种变长参数可以混合使用, 但变长位置参数一定要在变长关键字参数前</li><li>与变长位置参数对应的, 使用 <code>*&lt;序列类型对象&gt;</code> 可将<a href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列类型</a>中的元素以此解包为位置参数并传入函数 (函数不一定要接收变长位置参数)</li><li>与变长关键字参数对应的, 使用 <code>**&lt;字典对象&gt;</code> 可将<a href="#%E5%AD%97%E5%85%B8">字典</a>中的键值对以此解包为关键字参数并传入函数 (函数不一定要接收变长关键字参数, 字典中不能有非函数参数的键名)</li></ul><h4 id="限定参数" tabindex="-1"><a class="header-anchor" href="#限定参数" aria-hidden="true">#</a> 限定参数</h4><ul><li>在函数参数列表中, 使用伪参数名 (不是实际的参数) <code>/</code> 表示该参数前的所有参数只能是位置参数, 不能以关键字方式传入<br> 以可作为最后一个参数, 表明函数的所有参数均为仅位置参数</li><li>在函数参数列表中, 使用伪参数名 (不是实际的参数) <code>*</code> 表示该参数后的所有参数只能是关键字参数, 不能以位置方式传入<br> 以可作为第一个参数, 表明函数的所有参数均为仅关键字参数</li><li>以上两种限定参数可以混合使用, 但 <code>/</code> 一定要在 <code>*</code> 之前</li></ul><p>在实际使用时</p><ul><li>通常将没有实际意义的参数作为仅位置参数</li><li>通常将具有实际意义的参数作为仅关键字参数</li></ul><h3 id="函数的高级使用" tabindex="-1"><a class="header-anchor" href="#函数的高级使用" aria-hidden="true">#</a> 函数的高级使用</h3><h4 id="lambda-表达" tabindex="-1"><a class="header-anchor" href="#lambda-表达" aria-hidden="true">#</a> Lambda 表达</h4><p>Lambda 表达式可用于将复杂函数包装为简单形式并作为参数传递供其他函数调用<br> 其基本语法如下</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 基本语法</span>
fun <span class="token operator">=</span> <span class="token keyword">lambda</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>参数<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>参数<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> 函数体
<span class="token comment"># 示例</span>
z <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">**</span> <span class="token number">3</span> <span class="token operator">-</span> y
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>python 中的 Lambda 表达式有如下特点</p><ul><li>Lambda 表达式的参数除了不需要 <code>()</code> 包裹, 其余与一般函数完全相同</li><li>Lambda 表达式的函数体只能有一行, 且这一行的执行结果将作为表达式的返回值, 因此不需要 <code>return</code></li><li>在 Lambda 表达式中不允许赋值</li><li>Labmda 表达式同样允许设置默认值参数, 并且可以通过默认值参数实现状态保存, 例如以下例子</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>flist1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
flist2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    flist1<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token keyword">lambda</span> val <span class="token operator">=</span> i<span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
    flist2<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>

flist1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 输出 2, 循环中 i 的值作为默认值被保存下来</span>
flist2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 输出 9, 根据函数定义, 将使用变量 i 的最新值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="变量作用域" tabindex="-1"><a class="header-anchor" href="#变量作用域" aria-hidden="true">#</a> 变量作用域</h4><ul><li>函数内定义的变量将在函数退出后被销毁, 因此不会被访问</li><li>在函数内使用变量时, 将按从内到外直到该脚本文件的顺序搜索变量, 最内层的名称符合的变量将被使用</li><li>在函数内对全局变量赋值时, 并不会生效, 因为等同于定义了一个同名的局部变量 (不建议在函数内定义与全局变量同名的变量)<br> 但是在函数内通过变量的方法修改全局变量会生效</li><li>如果希望在函数内修改全局变量, 则需要先使用 <code>global &lt;全局变量&gt;</code> 进行声明</li><li>如果希望在函数内修改外部非全局变量, 则需要先使用 <code>nonlocal &lt;变量名&gt;</code> 进行声明, 将寻找外层最近的, 具有指定名称的变量</li></ul><h4 id="闭包与修饰器" tabindex="-1"><a class="header-anchor" href="#闭包与修饰器" aria-hidden="true">#</a> 闭包与修饰器</h4>`,64),E={href:"https://www.runoob.com/w3cnote/python-func-decorators.html",target:"_blank",rel:"noopener noreferrer"},f=o(`<p>对于闭包</p><ul><li>可以在函数中定义子函数, 并通过返回值将函数传递出去</li><li>子函数可以访问函数内的局部变量以及函数参数, 并且函数运行结束后子函数依然能访问</li></ul><p>对于修饰器</p><ul><li>修饰器的本质即在一个函数调用前与调用后, 执行部分代码, 但不改变函数原有的内容</li><li>修饰器即通过闭包实现, 首先将修饰器传入被修饰的函数, 修饰器创建一个包裹函数, 并返回</li><li>此外还可与使用 <code>@ + 修饰器</code> 的语法, 修饰器即一个以函数为参数的函数</li><li>推荐使用 <code>from functools import wraps</code> 并使用 <code>@wraps(fun)</code> 修饰包裹函数, 防止函数的原始信息被包裹函数覆盖</li><li>如果希望创建含参数的修饰器, 则可通过一个返回修饰器的函数实现, 该函数根据参数构造特定的修饰器 (此时函数内有两层嵌套)<br> 使用时需要以 <code>()</code> 向函数传递参数</li><li>如以下例子所示, 修饰器可用于</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> time
<span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps

<span class="token keyword">def</span> <span class="token function">simple_timer</span><span class="token punctuation">(</span>fun<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token decorator annotation punctuation">@wraps</span><span class="token punctuation">(</span>fun<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">wrap_function</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        ticks <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span>
        res <span class="token operator">=</span> fun<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        used_times <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ticks
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;</span><span class="token interpolation"><span class="token punctuation">{</span>fun<span class="token punctuation">.</span>__name__<span class="token punctuation">}</span></span><span class="token string"> used </span><span class="token interpolation"><span class="token punctuation">{</span>used_times<span class="token punctuation">}</span></span><span class="token string"> second&quot;</span></span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
    <span class="token keyword">return</span> wrap_function

<span class="token comment"># 创建方法 1</span>
<span class="token decorator annotation punctuation">@simple_timer</span>
<span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> res <span class="token operator">*</span> i
    <span class="token keyword">return</span> res

<span class="token comment"># 创建方法 2</span>
wrap_fun <span class="token operator">=</span> simple_timer<span class="token punctuation">(</span>fun<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="模块" tabindex="-1"><a class="header-anchor" href="#模块" aria-hidden="true">#</a> 模块</h2><p>在 Python 中, 将单个 Python 文件视为一个模块, 模块名即 Python 文件名 (不包括后缀)</p><h3 id="模块导入命令" tabindex="-1"><a class="header-anchor" href="#模块导入命令" aria-hidden="true">#</a> 模块导入命令</h3><ul><li>使用 <code>import &lt;模块名&gt;</code> 可直接导入模块, 此时需要 <code>&lt;模块名&gt;.&lt;模块全局变量&gt;</code> 的方式调用模块内的函数或变量</li><li>使用 <code>from &lt;模块名&gt; import &lt;模块变量1&gt;[, &lt;模块变量2&gt;[, ...]]</code> 可从模块内导入特定变量, 模块或方法到当前程序的全局变量中 <ul><li>使用 <code>*</code> 作为模块变量名则将导入整个模块内的变量到当前程序, 由于可能造成变量冲突, 因此不建议使用此方法</li></ul></li><li>在导入语句后使用 <code>as &lt;新名称&gt;</code> 可以指定名称作为导入模块或变量的新名称</li><li>导入模块时不需要给出模块路径, 导入时将首先搜索当前模块所在目录, 然后搜索环境变量 <code>PYTHONPATH</code>, 最后搜索依赖于安装的默认值, 搜索目录位于模块 <code>sys</code> 的变量 <code>sys.path</code> 中</li></ul><h3 id="模块导入行为" tabindex="-1"><a class="header-anchor" href="#模块导入行为" aria-hidden="true">#</a> 模块导入行为</h3><ul><li>在一个解释器内, 当一个模块被导入后, 即使该模块被修改也不会再被重新导入<br> 可使用 <code>importlib</code> 模块的方法 <code>importlib.reload(modulename)</code> 强制重新导入</li><li>每当一个模块被导入时, 将首先运行该模块内的代码</li><li>除了<a href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%91%BD%E4%BB%A4">在一个模块中带入另一个模块</a>, 还可使用 <code>python &lt;模块名&gt; [参数]</code> 将模块作为脚本运行 (此时要带有完整的后缀与路径)</li><li>对于每个模块都有变量 <code>__name__</code>, 表明该模块的导入名称, 如果该模块被作为程序运行, 则有 <code>__name__ == &quot;__main__&quot;</code> (即作为程序在顶层运行的模块总是以名称 <code>__main__</code> 导入)<br> 因此通过 <code>if __name__ == &quot;__main__&quot; :</code> 可判断模块是否被作为程序运行, 并执行相应代码</li></ul><h3 id="包" tabindex="-1"><a class="header-anchor" href="#包" aria-hidden="true">#</a> 包</h3><ul><li>除了将单个 Python 文件作为一个模块, 还可使用一个文件夹表示模块, 称为包, 该文件夹名即模块名</li><li>此时要求该文件夹中必须有文件 <code>__init__.py</code>, 即使用该脚本文件代表了该文件夹是一个模块, 也将在导入模块时运行该脚本 (可以是空文件)</li><li>当导入包时, 将该文件夹下所有 Python 文件都作为包的子模块, 也可使用 <a href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%91%BD%E4%BB%A4">from</a> 的方式导入特定自模块</li><li>允许包中的文件夹作为子包使用</li><li>在多个子包中, 如果希望引用上级包或同级子包中的模块, 需要相对引用, 与相对路径类似<br> 使用 <code>.</code> 表示当前包, <code>..</code> 表示上层包, <code>..&lt;子包名&gt;</code> 表示同级子包</li></ul><h2 id="异常与错误" tabindex="-1"><a class="header-anchor" href="#异常与错误" aria-hidden="true">#</a> 异常与错误</h2><h3 id="处理异常" tabindex="-1"><a class="header-anchor" href="#处理异常" aria-hidden="true">#</a> 处理异常</h3><p>异常处理语句的基本结构如下</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">except</span> <span class="token operator">&lt;</span>exc1<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token keyword">as</span> <span class="token operator">&lt;</span>exc_name1<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token keyword">except</span> <span class="token operator">&lt;</span>exc2<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token keyword">as</span> <span class="token operator">&lt;</span>exc_name2<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token keyword">finally</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>try</code> 部分用于检测与捕获异常, 当其中的语句出现异常将交由 <code>except</code> 捕获</li><li><code>except</code> 用于捕获类型或父类型为 <code>exc</code> 的异常, 可参考<a href="#%E8%A7%A6%E5%8F%91%E5%BC%82%E5%B8%B8">触发异常</a><ul><li>使用 <code>as &lt;exc_name1&gt;</code> 表示将异常对象捕获后作为变量 <code>exc_name1</code> 处理</li><li>允许有多个异常捕获语句, 当异常被捕获后, 将运行其下对应的子程序</li><li>由于 <code>Exception</code> 为所有异常的基类, 因此 <code>except Exception</code> 能捕获所有异常, 之后可通过 <a href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">type()</a> 判断异常类型</li></ul></li><li><code>else</code> 部分用于处理没有任何异常被捕获的情况 <ul><li>如果有 <code>except Exception</code> 语句, 则将表示没有异常的情况</li></ul></li><li><code>finally</code> 用于执行异常处理后的清理操作 <ul><li>通常在使用资源如文件或网络时, 使用 <code>try</code> 检查异常, 并使用 <code>finally</code> 释放资源</li><li>无论如何 <code>finally</code> 语句总会在最后被触发, 即使 <code>try</code> 或 <code>excpt</code> 语句内出现 <code>return</code> 或再次触发异常</li><li><code>except</code> 语句内在触发的异常前先执行 <code>finally</code> 然后再触发异常</li><li><code>try</code> 语句内在触发的 <code>return</code> 前先执行 <code>finally</code> 然后再执行 <code>return</code>, 如果 <code>finnaly</code> 内也有 <code>return</code>, 则优先执行 <code>finally</code> 内的语句</li></ul></li></ul><h3 id="触发异常" tabindex="-1"><a class="header-anchor" href="#触发异常" aria-hidden="true">#</a> 触发异常</h3><ul><li>使用 <code>raise &lt;异常对象&gt;</code> 命令可用于触发异常, 其中 <code>异常对象</code> 必须是异常基类 <code>Exception</code> 及其派生类<br> 当该语句被调用时, 将中断程序并寻找最上层的<a href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">处理异常</a>语句, 如果不存在将退出程序</li><li>通常异常对象都使用一段表示异常原因的字符串为参数实例化, 常用的内置异常类有 <ul><li><code>Exception</code> 即一般的异常, 也是内置异常或用户自定义异常的基类</li><li><code>NameError</code> 变量名称为被查找到</li><li><code>TypeError</code> 类型不满足要求引发的异常</li><li><code>ValueError</code> 参数值不适合引发的异常</li><li><code>IndexError</code> 索引超出范围引发的异常</li><li><code>RuntimeError</code> 运行时错误</li></ul></li><li>异常链 <ul><li>当在处理异常的 <code>except</code> 语句中再次触发异常, 则将形成异常链, 将异常附加到被处理异常上</li><li>直接使用 <code>raise</code> 可再次抛出处理的异常</li><li>假设捕获了异常 <code>e</code>, 使用异常对象的方法 <code>e.add_note(str)</code> 可以为再次抛出的异常补充注释</li><li>使用 <code>raise &lt;新异常对象&gt; from &lt;捕获的异常&gt;</code> 可以强调两者存在强因果关系</li><li>使用 <code>raise &lt;新异常对象&gt; from None</code> 可以取消异常链</li></ul></li><li>使用内置异常对象 <code>ExceptionGroup</code> 表示异常组, 异常组对象除了异常原因字符串, 还接收一个异常组成的元组, 表示异常由多个原因组成</li></ul><h3 id="预定义异常处理" tabindex="-1"><a class="header-anchor" href="#预定义异常处理" aria-hidden="true">#</a> 预定义异常处理</h3><p>主要用于资源管理类</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">with</span> <span class="token operator">&lt;</span>exp<span class="token operator">&gt;</span> <span class="token keyword">as</span> <span class="token operator">&lt;</span>target<span class="token operator">&gt;</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>该语句等价于</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    target <span class="token operator">=</span> exp<span class="token punctuation">.</span>__enter__<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">except</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">as</span> e<span class="token punctuation">:</span>
    hit_exp <span class="token operator">=</span> <span class="token boolean">True</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> target<span class="token punctuation">.</span>__exit__<span class="token punctuation">(</span>e_type<span class="token punctuation">,</span> e_val<span class="token punctuation">,</span> traceback<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span>
<span class="token keyword">finally</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> hit_exp<span class="token punctuation">:</span>
        target<span class="token punctuation">.</span>__exit__<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此</p><ul><li><code>exp</code> 为一个具有预定义异常处理能力的资源管理对象</li><li><code>target</code> 为一个变量, 用于接收表达式 <code>exp</code> 成员 <code>__enter__</code> 的结果, 并在语句结束后销毁</li><li>要求具有预定义异常处理能力的对象有以下两个成员方法 <ul><li><code>__enter__()</code> 返回供给 <code>target</code> 的资源</li><li><code>__exit__(type, val, traceback)</code> 用于回收提供给 <code>target</code> 的资源, 函数接收异常的类型, 值与上下文 <ul><li>当该函数返回 <code>True</code> 表明异常与资源回收处理完成并正常退出</li><li>当正常回收资源时, 三个参数均为 <code>None</code></li><li>不应该在该函数中触发异常</li></ul></li></ul></li><li>该语句通常用于配合打开文件操作, 如 <code>with open(文件名) as f:</code><br> 此时该语句中的程序访问文件资源, 并在退出语句时保证释放打开的文件</li></ul><h3 id="异常回溯" tabindex="-1"><a class="header-anchor" href="#异常回溯" aria-hidden="true">#</a> 异常回溯</h3><p>标准模块 <code>traceback</code> 可用于异常信息的回溯<br> 虽然一般情况下 Python 能自动打印异常回溯信息, 但对于多线程等特殊情况, 可能需要手动获取异常回溯信息</p><p>模块方法 <code>traceback.print_exception(exc, /, limit = None, file = None, chain = True)</code> 获取异常回溯信息</p>`,30),y=n("li",null,[n("code",null,"exc"),a(" 被回溯的异常对象")],-1),g=n("li",null,[n("code",null,"limit"),a(" 回溯层数 "),n("ul",null,[n("li",null,[a("传入 "),n("code",null,"None"),a(" 将回溯所有信息")]),n("li",null,"传入正整数将从异常出现的最底层代码回溯"),n("li",null,"传入负数从反方向回溯, 即出现异常的最顶层代码")])],-1),_=n("code",null,"file",-1),B=n("li",null,[a("传入 "),n("code",null,"None"),a(" 将打印到 "),n("code",null,"stderr"),a(" 上")],-1),x=n("li",null,[n("code",null,"chain"),a(" 是否打印造成异常的详细原因")],-1),A=o(`<h3 id="警告" tabindex="-1"><a class="header-anchor" href="#警告" aria-hidden="true">#</a> 警告</h3><p>除了一般的异常, 还存在警告这一类特殊的异常, 警告同样继承自异常基类 <code>Exception</code></p><ul><li>仅当是警告基类 <code>Warning</code> 的基类才能作为警告</li><li>一般将内置异常类名称中的 <code>Error</code> 换为 <code>Warning</code> 即内置警告类</li><li>当警告通过 <a href="#%E8%A7%A6%E5%8F%91%E5%BC%82%E5%B8%B8">raise</a> 触发时效果于一般的异常相同</li></ul><p>警告一般使用 <code>warning</code> 模块下的方法 <code>warn</code> 触发<br> 方法 <code>warning.warn(message, category = ...)</code> 触发警告</p><ul><li><code>message</code> 警告内容, 传入字符串</li><li><code>category</code> 警告类型, 传入任意继承自 <code>Warning</code> 的类型, 默认为 <code>UserWarning</code></li><li>当警告触发是程序不会终止, 仅打印警告到标准错误上, 且不会重复触发</li></ul><h2 id="类的基础" tabindex="-1"><a class="header-anchor" href="#类的基础" aria-hidden="true">#</a> 类的基础</h2><h3 id="类的使用" tabindex="-1"><a class="header-anchor" href="#类的使用" aria-hidden="true">#</a> 类的使用</h3><h4 id="类的定义" tabindex="-1"><a class="header-anchor" href="#类的定义" aria-hidden="true">#</a> 类的定义</h4><p>使用如下的语法定义一个类</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token operator">&lt;</span>ClassName<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
<span class="token punctuation">[</span><span class="token triple-quoted-string string">&#39;&#39;&#39;
&lt;docs&gt;
&#39;&#39;&#39;</span><span class="token punctuation">]</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    val <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>类定义说明 <ul><li><code>ClassName</code> 即类的名称, 通常类名称以大写字母开头并且使用大小写区分单词</li><li><code>(...)</code> 类的继承, 参考<a href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">类的继承</a></li><li><code>docs</code> 类的说明文档, 与<a href="#%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">函数</a>相同</li></ul></li><li>类的实例化 <ul><li>通过 <code>&lt;变量名&gt; = &lt;类名&gt;(...)</code> 的方法可以创建类的实例, 即对象</li><li>类实例化后的对象同样使用 <code>.</code> 运算符访问对象成员</li><li>将通过类内定义的特殊方法 <code>def __init__(self, ...)</code> 实例化对象, 即构造函数</li></ul></li><li>类的性质 <ul><li>在 Python 中, 以上语法定义的类可以视为一个特殊的模块, 类内定义的函数与变量均为该模块下的函数与变量, 因此类下的静态成员同样通过 <code>.</code> 运算符访问</li><li>类也存在<a href="#%E9%97%AD%E5%8C%85%E4%B8%8E%E4%BF%AE%E9%A5%B0%E5%99%A8">修饰器</a>语法, 通过特殊的修饰器修饰类可用于创建特殊行为的类如, <a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB">数据类</a></li></ul></li></ul><h4 id="公有成员定义" tabindex="-1"><a class="header-anchor" href="#公有成员定义" aria-hidden="true">#</a> 公有成员定义</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Example</span><span class="token punctuation">:</span>
    <span class="token comment"># 静态成员常量</span>
    STATIC_VARIABLE <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token comment"># 类构造函数</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 公有成员变量与常量</span>
        self<span class="token punctuation">.</span>public_variable <span class="token operator">=</span> <span class="token number">1</span>
        self<span class="token punctuation">.</span>PUBLIC_CONST <span class="token operator">=</span> <span class="token number">2</span>

        <span class="token comment"># 私有成员变量</span>
        self<span class="token punctuation">.</span>_private_variable <span class="token operator">=</span> value

    <span class="token comment"># 属性的创建与常见用途 (创建只读量)</span>
    <span class="token decorator annotation punctuation">@property</span>
    <span class="token keyword">def</span> <span class="token function">class_value</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_private_variable

    <span class="token comment"># 一般函数</span>
    <span class="token keyword">def</span> <span class="token function">set_fun</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 注意, 可通过 self 直接访问静态成员</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>STATIC_VARIABLE<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>_private_variable <span class="token operator">=</span> value

    <span class="token comment"># 静态方法</span>
    <span class="token decorator annotation punctuation">@classmethod</span>
    <span class="token keyword">def</span> <span class="token function">info</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 静态成员在静态方法中的访问</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span>STATIC_VARIABLE<span class="token punctuation">)</span>

<span class="token comment"># 类的实例化</span>
a <span class="token operator">=</span> Example<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment"># 属性的使用</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>class_value<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可在类层级下定义类函数, 在 Python 中一般称类的函数为方法 <ul><li>对于一般方法, 必须以 <code>self</code> 作为第一个参数, 该参数即类的实例对象, 通过类的对象使用方法时不需要传入</li><li>对于静态方法, 需要使用内置修饰器 <code>@classmethod</code> 修饰函数, 并且以 <code>cls</code> 作为第一个参数, 该参数即静态方法所在的类本身, 使用静态方法时不需要传入 <ul><li>Python 中一般将与该类有关的实用方法定义为其静态方法</li></ul></li></ul></li><li>类的成员变量使用以下方法定义 <ul><li>在类的方法内, 通过对 <code>self</code> 访问的未定义类变量赋值即可定义一般成员变量</li><li>直接在类层级下通过赋值定义变量将直接作为类的静态成员变量, 当大写时即常量静态成员</li><li>通过内置修饰器 <code>@property</code> 修饰一个仅接收 <code>self</code> 并存在返回值的函数, 可以创建类的属性, 属性是一种特殊的成员, 在通过对象访问属性时, 使用的是访问成员变量的语法, 但实际将调用对应的方法并以其返回值作为访问结果, 可以此包装只读量等</li></ul></li><li>访问类与对象时 <ul><li>对于一般方法与成员变量, 使用 <code>&lt;对象变量&gt;.&lt;成员变量 / 方法&gt;</code> 的方式访问</li><li>对于静态成员, 可使用 <code>&lt;类名&gt;.&lt;静态成员 / 方法&gt;</code> 的方式访问, 同样也可通过如 <code>self</code> 的 <code>&lt;对象变量&gt;</code> 访问静态成员</li></ul></li></ul><h4 id="私有成员定义" tabindex="-1"><a class="header-anchor" href="#私有成员定义" aria-hidden="true">#</a> 私有成员定义</h4>`,15),w=n("li",null,[a("Python 中不存在实际的私有成员, 但约定使用一个下划线 "),n("code",null,"_"),a(" 为前缀表示类的私有变量或对象的私有成员, 该成员可被子类与父类访问, 因此更接近 C++ 的保护成员")],-1),q=n("code",null,"__",-1),F=n("code",null,"_<类名>__xxx",-1),C=n("code",null,"__xxx",-1),D=n("li",null,[a("虽然 "),n("code",null,"__xxx"),a(" 依然可以在对象中直接访问, 但是由于名称改写, 因此子类无法访问父类名称为 "),n("code",null,"__xxx"),a(" 的成员, 以此实现变量相对子类的私有属性, 即 C++ 中严格的私有成员")],-1),P=n("li",null,[a("但是子类依然可以通过 "),n("code",null,"_<父类名>__xxx"),a(" 强制访问父类的私有属性 "),n("code",null,"__xxx")],-1),N={href:"https://docs.python.org/zh-cn/3/tutorial/classes.html#private-variables",target:"_blank",rel:"noopener noreferrer"},T=n("h3",{id:"类的继承",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#类的继承","aria-hidden":"true"},"#"),a(" 类的继承")],-1),z={href:"https://docs.python.org/zh-cn/3/tutorial/classes.html#inheritance",target:"_blank",rel:"noopener noreferrer"},L=o(`<p>在类创建时, 使用类名后的 <code>()</code> 内传入父类, 即可创建继承自父类的子类, 关于定义示例见<a href="#%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB">访问父类</a><br> 虽然 Python 也支持多重继承, 但除了特殊情况不建议使用, 应当通过组合代替, 因此此处不介绍</p><p>通过类的继承</p><ul><li>子类将获得父类中已经定义的方法与成员变量, 且<mark>可直接访问父类的静态方法与变量</mark></li><li>使用 <a href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">isinstance</a> 函数时, 认为子类的实例同时也是父类的实例, 例如在<a href="#%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB">示例</a>中, 表达式 <code>isinstance(obj, A)</code> 为真</li><li>在继承中, 还有函数 <code>issubclass(&lt;子类&gt;, &lt;父类&gt;)</code> 可用于判断两个类型的关系, 例如在<a href="#%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB">示例</a>中, 表达式 <code>issubclass(C, A)</code> 为真</li></ul><h4 id="访问父类" tabindex="-1"><a class="header-anchor" href="#访问父类" aria-hidden="true">#</a> 访问父类</h4><p>使用子类的实例时, 将首先搜索子类命名空间内的对象成员, 如果搜索不到将尝试寻找父类的属性与方法<br><mark>因此对于 Python, 所有的对象方法都等同于 C++ 中的虚函数</mark></p><p>当子类与父类具有相同名称的方法, 且需要访问父类方法时</p><ul><li>可通过在类方法内通过内置类 <code>super()</code> 构造对象, 通过该对象访问父类</li><li>当在类定义外使用 <code>super</code> 时, 需要传入 <code>super(&lt;对象类型&gt;, &lt;操作对象&gt;)</code></li><li>由于方法将自动覆盖, 因此子类一般需要在构造函数中显示的调用父类的构造函数</li></ul><p>以下为继承与父类访问的示例</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>v_A <span class="token operator">=</span> value
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;in A init&quot;</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;in A fun&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 注意在子类中显式的调用父类构造函数</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;in C init&quot;</span><span class="token punctuation">)</span>
    
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;in C fun&quot;</span><span class="token punctuation">)</span>

obj <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment"># 类外调用父类方法</span>
<span class="token builtin">super</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 没有冲突时, 则可以直接调用父类的成员</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>v_A<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="抽象基类" tabindex="-1"><a class="header-anchor" href="#抽象基类" aria-hidden="true">#</a> 抽象基类</h4><p>Python 中, 需要通过继承模块 <code>abc</code> 下的类 <code>ABC</code> 创建抽象基类</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> abc <span class="token keyword">import</span> ABC<span class="token punctuation">,</span> abstractmethod

<span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">(</span>ABC<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>a <span class="token operator">=</span> a

    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">)</span>

    <span class="token comment"># 一般抽象方法</span>
    <span class="token decorator annotation punctuation">@abstractmethod</span>
    <span class="token keyword">def</span> <span class="token function">set_value</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment"># 抽象属性</span>
    <span class="token decorator annotation punctuation">@property</span>
    <span class="token decorator annotation punctuation">@abstractmethod</span>
    <span class="token keyword">def</span> <span class="token function">value</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment"># 抽象静态方法</span>
    <span class="token decorator annotation punctuation">@classmethod</span>
    <span class="token decorator annotation punctuation">@abstractmethod</span>
    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用抽象基类时注意</p><ul><li>抽象基类中, 通过<a href="#%E9%97%AD%E5%8C%85%E4%B8%8E%E4%BF%AE%E9%A5%B0%E5%99%A8">修饰器</a> <code>abstractmethod</code> 确定了基类中, 子类必须实现的抽象方法, 如果没有实现将会出错</li><li>不需要给出抽象方法的定义, 可使用 <code>...</code> 代替</li><li>修饰特殊方法时, 应保证 <code>abstractmethod</code> 修饰器在最后</li><li>允许抽象基类中存在一般方法, 同样可通过 <a href="#%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB">super()</a> 访问</li></ul><h3 id="运算符重载与类型转换" tabindex="-1"><a class="header-anchor" href="#运算符重载与类型转换" aria-hidden="true">#</a> 运算符重载与类型转换</h3><p>类的函数使用名称 <code>__xxx__</code> 时表示的是特殊方法, 这些方法通常都有实际含义, 如构造函数 <code>__init__</code><br> 以下为一些用于运算符重载与类型转换的特殊方法</p><ul><li><code>__str__(self)</code> 将对象转换为可读的字符串, 要求返回字符串</li><li><code>__repr__(self)</code> 将对象转换为一个可用于创建自身的字符串, 要求返回字符串, 当 <code>__str__</code> 未定义时将代替之</li><li><code>__bool__(self)</code> 将对象转换为布尔值, 要求返回布尔值</li><li><code>__eq__(self, other)</code> 对象的等号 <code>==</code> 运算符重载, 要求返回布尔值, 默认使用 <a href="#%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6">is</a></li><li><code>__ne__(self, other)</code> 对象的不等号 <code>!=</code> 运算符重载, 要求返回布尔值, 默认使用 <a href="#%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6">not is</a></li></ul><p>注意到, 重载运算符时, 对象总是位于运算符的左侧, 因此如果希望正确发挥重载运算符的效果, <mark>二元运算时尽量让对象位于运算符左侧, 一般值位于右侧</mark></p><h2 id="类的高级使用" tabindex="-1"><a class="header-anchor" href="#类的高级使用" aria-hidden="true">#</a> 类的高级使用</h2><h3 id="类型模拟" tabindex="-1"><a class="header-anchor" href="#类型模拟" aria-hidden="true">#</a> 类型模拟</h3><p>通过重载一套运算符, 可以完成类关于特定类型的模拟, 具体可参考官方文档</p>`,21),R={href:"https://docs.python.org/zh-cn/3/reference/datamodel.html#emulating-container-types",target:"_blank",rel:"noopener noreferrer"},I={href:"https://docs.python.org/zh-cn/3/reference/datamodel.html#emulating-numeric-types",target:"_blank",rel:"noopener noreferrer"},j={href:"https://docs.python.org/zh-cn/3/reference/datamodel.html#with-statement-context-managers",target:"_blank",rel:"noopener noreferrer"},H=n("br",null,null,-1),S=n("a",{href:"#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"},"with",-1),U=o(`<h3 id="数据类" tabindex="-1"><a class="header-anchor" href="#数据类" aria-hidden="true">#</a> 数据类</h3><p>在部分情况下, 希望将类以类似 C++ 的 <code>struct</code> 的方式使用, 则可以通过来自模块 <code>dataclasses</code> 的修饰器 <code>dataclass</code> 创建修饰类<br> 示例如下</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> dataclasses <span class="token keyword">import</span> dataclass

<span class="token decorator annotation punctuation">@dataclass</span>
<span class="token keyword">class</span> <span class="token operator">&lt;</span>DataClass<span class="token operator">&gt;</span><span class="token punctuation">:</span>
    <span class="token operator">&lt;</span>key1<span class="token operator">&gt;</span> <span class="token punctuation">:</span> <span class="token operator">&lt;</span>type1<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>key2<span class="token operator">&gt;</span> <span class="token punctuation">:</span> <span class="token operator">&lt;</span>type2<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token operator">&lt;</span>default_val2<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>虽然使用的语法 <code>&lt;key1&gt; : &lt;type1&gt;</code> 适用于定义静态变量, 但经过修饰后, 数据类将以此为实例对象创建一个名称为 <code>key1</code> 类型为 <code>type1</code> 的属性 (注意必须给出类型 <code>type1</code>)</li><li>可通过 <code>&lt;key2&gt; : &lt;type2&gt; = &lt;default_val2&gt;</code> 指定数据类特定对象的默认值为 <code>&lt;default_val2&gt;</code> (更推荐使用函数 <a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E7%9A%84%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8">field</a>)</li><li>在数据类将自动生成构造函数, 可通过 <code>DataClass(key1, key2, ...)</code> 按顺序传入数据类各对象的值</li><li>此外还将自动创建字符串转换 <code>__repr__</code> 方法与重载相等运算符</li><li>对于常量数据类, 可通过<a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E6%94%AF%E6%8C%81%E6%9E%9A%E4%B8%BE%E7%B1%BB">数据类支持枚举类</a>的方式定义</li></ul><h4 id="数据类的高级使用" tabindex="-1"><a class="header-anchor" href="#数据类的高级使用" aria-hidden="true">#</a> 数据类的高级使用</h4><ul><li>使用模块 <code>dataclass</code> 下的函数 <code>field(*, default = ..., default_factory = ..., compare = True, metadata = False)</code> 可对属性进行更高级的设置 <ul><li><code>default</code> 属性默认值, 用于设置<a href="#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">不可变对象</a>类型属性的默认值</li><li><code>default_factory</code> 属性默认值的工厂函数 (一个返回默认值且不接受参数的函数), 根据<a href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%82%E6%95%B0">默认值参数</a>可知, 不能直接将可变参数作为默认值</li><li><code>compare</code> 该参数是否参与比较</li><li><code>metadata</code> 是否使用该属性保存元数据, 取为 <code>True</code> 时该属性的类型为字典或 <code>None</code>, 且不可修改</li></ul></li></ul><h3 id="枚举类" tabindex="-1"><a class="header-anchor" href="#枚举类" aria-hidden="true">#</a> 枚举类</h3>`,7),V={href:"https://docs.python.org/zh-cn/3/howto/enum.html",target:"_blank",rel:"noopener noreferrer"},G=o(`<p>在 Python 中, 没有直接提供枚举类型, 但可通过继承模块 <code>emun</code> 下的类实现各种特性的枚举类</p><h4 id="枚举类基础定义" tabindex="-1"><a class="header-anchor" href="#枚举类基础定义" aria-hidden="true">#</a> 枚举类基础定义</h4><p>基础枚举基类为 <code>Enum</code>, 定义枚举类型时, 继承枚举基类, 通过定义类的<a href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89">静态成员</a>确定枚举量的名称, 将静态成员的值作为枚举量对应的值<br> 例如</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum
<span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
    RED <span class="token operator">=</span> <span class="token number">0</span>
    BLUE <span class="token operator">=</span> <span class="token number">1</span>
    GREEN <span class="token operator">=</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义枚举类时注意</p><ul><li>枚举量的名称与对应值都不应该重复</li><li>枚举量的名称最好大写, 以此表示常量静态成员, 以防止以外修改</li></ul><h4 id="枚举类型的使用" tabindex="-1"><a class="header-anchor" href="#枚举类型的使用" aria-hidden="true">#</a> 枚举类型的使用</h4><p>对于继承自 <code>Enum</code> 的枚举类型, 有以下常用操作 (此处以<a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89">上文</a>定义的枚举类型举例)</p><ul><li>枚举量获取 <ul><li>通过 <code>&lt;枚举类型&gt;.&lt;枚举量&gt;</code> 的方式即可访问枚举量, 并用于赋值</li><li>将枚举量对应的值构造枚举类型也可创建对应的枚举量, 例如表达式 <code>Color(0) == Color.RED</code> 为真</li><li>也可通过枚举量名称的方式访问枚举量, 此时需要对枚举类型使用 <code>[]</code> 运算赋, 传入枚举量名称字符串, 例如表达式 <code>Color[&#39;RED&#39;] == Color.RED</code> 为真</li></ul></li><li>枚举量的成员 <ul><li>认为枚举量为对应枚举类型的实例, 因此表达式 <code>isinstance(Color.RED, Color)</code> 为真</li><li>通过成员 <code>name</code> 可访问枚举量的名称, 以字符串形式保存</li><li>通过成员 <code>value</code> 可获取枚举量对应的值</li><li>枚举量之间可通过 <code>==</code> 与 <code>!=</code> 比较, 但无法使用不等号如 <code>&gt;</code> 比较, 也无法与对应的值比较, 例如表达式 <code>Color.RED == 0</code> 为假</li></ul></li><li>枚举类型的其他使用 <ul><li>通过枚举类型的静态成员 <code>__members__</code> 的 <code>keys(), values(), items()</code> 方法可分别迭代枚举量对应名称, 枚举量, 二者组成的元组</li><li>允许为枚举类型定义<a href="#%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8">静态方法</a></li></ul></li></ul><h4 id="标志位类型" tabindex="-1"><a class="header-anchor" href="#标志位类型" aria-hidden="true">#</a> 标志位类型</h4><ul><li>继承自基类 <code>enum.Flag</code>, 基础使用与<a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8">枚举类型的使用</a>一致</li><li>标志位类型中, 每个枚举量表示一个二进制标志位, 因此一般枚举量对应值为 2 的幂, 且允许枚举量之间的<a href="#%E4%BD%8D%E8%BF%90%E7%AE%97">位运算</a></li><li>除此之外, 在满足枚举量对应值不重复的基础上, 允许使用之前枚举量的组合或 <code>0</code>, 但通过静态成员 <code>__members__</code> 遍历枚举类时, 只有以值位 2 的幂的枚举量会被访问</li><li>建议使用函数 <code>enum.auto()</code> 自动确定枚举量对应的值 (该函数也可用于 <code>Enum</code> 以自动确定值)</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> enum <span class="token keyword">import</span> Flag<span class="token punctuation">,</span> auto

<span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Flag<span class="token punctuation">)</span><span class="token punctuation">:</span>
    RED <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
    BLUE <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
    GREEN <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
    WHITE <span class="token operator">=</span> RED <span class="token operator">|</span> BLUE <span class="token operator">|</span> GREEN
    BLACK <span class="token operator">=</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="数据类支持枚举类" tabindex="-1"><a class="header-anchor" href="#数据类支持枚举类" aria-hidden="true">#</a> 数据类支持枚举类</h4><p>如果希望以<a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB">数据类</a>对象作为枚举类的值, 应使用以下方式定义枚举类</p><ul><li>枚举类应同时继承所需数据类与 <code>Enum</code></li><li>数据类中不允许有属性 <code>name</code> 与 <code>value</code> (与 <code>Enum</code> 的相关成员变量冲突)</li><li>定义枚举量的值时, 需要传入构造数据类对应的元组, 而不是直接传入数据类</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum
<span class="token keyword">from</span> dataclasses <span class="token keyword">import</span> dataclass

<span class="token decorator annotation punctuation">@dataclass</span>
<span class="token keyword">class</span> <span class="token class-name">ColorInfo</span><span class="token punctuation">:</span>
    color_name <span class="token punctuation">:</span> <span class="token builtin">str</span>
    color_value <span class="token punctuation">:</span> <span class="token builtin">int</span>

<span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>ColorInfo<span class="token punctuation">,</span> Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
    RED <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token number">0xFF0000</span><span class="token punctuation">)</span>
    BLUE <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token number">0x0000FF</span><span class="token punctuation">)</span>
    GREEN <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&quot;green&quot;</span><span class="token punctuation">,</span> <span class="token number">0x00FF00</span><span class="token punctuation">)</span>

<span class="token comment"># 使用示例, 创建枚举量与颜色名的映射</span>
color_name_dict <span class="token operator">=</span> <span class="token punctuation">{</span>value <span class="token punctuation">:</span> value<span class="token punctuation">.</span>color_name <span class="token keyword">for</span> value <span class="token keyword">in</span> Color<span class="token punctuation">.</span>__members__<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="附录" tabindex="-1"><a class="header-anchor" href="#附录" aria-hidden="true">#</a> 附录</h2><h3 id="字符串格式化表示方法" tabindex="-1"><a class="header-anchor" href="#字符串格式化表示方法" aria-hidden="true">#</a> 字符串格式化表示方法</h3>`,18),X=n("br",null,null,-1),W=n("br",null,null,-1),O={href:"http://www.cppcns.com/jiaoben/python/287553.html",target:"_blank",rel:"noopener noreferrer"},Y=n("br",null,null,-1),K={href:"https://zhuanlan.zhihu.com/p/295621558",target:"_blank",rel:"noopener noreferrer"},M=o(`<ul><li>参数填充 <ul><li><code>{}</code> 按输入参数顺序填充</li><li><code>{n}</code> 填充第 n 个参数, 从 0 开始计算</li><li><code>{val}</code> 填充入名称为 val 的参数</li><li>示例</li></ul></li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 基本替换</span>
<span class="token string">&quot;y = {}x + {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 &quot;y = ax + 12&quot;</span>

<span class="token comment"># 按参数位置替换</span>
<span class="token string">&quot;y = {0}x^2 +{1}x + {0}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 &quot;y = ax^2 +12x + a&quot;</span>

<span class="token comment"># 按参数名称替换</span>
<span class="token string">&quot;y = {num}x^2 +{param}x + {num}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>num <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">,</span> param <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 &quot;y = 12x^2 +ax + 12&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>字符串填充规则<br> 占用 n 个字符的宽度, 空白位置使用 <code>x</code> 填充 (未指定则使用空格) <ul><li><code>{:x&lt;n}</code> 左对齐</li><li><code>{:x&gt;n}</code> 右对齐</li><li><code>{:x^n}</code> 居中对齐</li><li>示例</li></ul></li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 宽度控制</span>
<span class="token comment"># 左对齐</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;out:{str:&lt;10}\\n    0123456789&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出</span>
<span class="token comment"># out:Hello     </span>
<span class="token comment">#     0123456789</span>

<span class="token comment"># 右对齐</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;out:{str:&gt;10}\\n    0123456789&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出</span>
<span class="token comment"># out:     Hello</span>
<span class="token comment">#     0123456789</span>

<span class="token comment"># 居中对齐</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;out:{str:^10}\\n    0123456789&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出</span>
<span class="token comment"># out:  Hello   </span>
<span class="token comment">#     0123456789</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>数字格式化 <ul><li><code>{:.nf}</code> 保留 n 位小数</li><li><code>{:.n%}</code> 百分数, n 为百分数后的小数位</li><li><code>{:.ne}</code> 科学计数法, n 为小数部分的小数位</li><li><code>{:+}</code> 带符号 (前缀)</li><li><code>{:,}</code> 千位分隔符 (前缀)</li><li><code>{x&gt;/&lt;/^n}</code> 对齐, 含义见上 (前缀)</li><li><code>{:#X}</code> 十六进制 (仅用于整数)<br> 对于十六进制宽度通过此方法控制 <code>{:#n_X}</code>, <code>n</code> 为宽度<br> 也可使用 <code>O</code>, <code>x</code> 表示八进制或十六进制小写</li></ul></li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 保留 n 位小数</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{pi:.3f}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pi <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 3.142</span>

<span class="token comment"># 百分数</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{pi:.2%}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pi <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 314.16%</span>

<span class="token comment"># 科学计数法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{pi:.3e}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pi <span class="token operator">=</span> <span class="token number">314159</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 3.142e+05</span>

<span class="token comment"># 带符号保留</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{pi:+.3f}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pi <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 +3.142</span>

<span class="token comment"># 千位分隔符</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{num:,}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>num <span class="token operator">=</span> <span class="token number">3141.5926</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 3,141.5926</span>

<span class="token comment"># 对齐</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;out: {pi:0^10.2f}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pi <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 out: 0003.14000</span>

<span class="token comment"># 十六进制</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{pi:#X}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>pi <span class="token operator">=</span> <span class="token number">314159</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 输出 0X4CB2F</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>{}</code> 转义<br> 使用 <code>{{}}</code> 可对 <code>{}</code> 进行转义, 保留并输出 <code>{}</code><br> 示例</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token string">&quot;\\\\frac{{{y}}}{{x}}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token operator">&gt;</span> <span class="token string">&#39;\\frac{10}{x}&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>混合格式</li></ul><p>对于以上各种格式可以混合使用, 具体规则如下</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]
fill            ::=  &lt;any character&gt;
align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;
sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;
width           ::=  digit
grouping_option ::=  &quot;_&quot; | &quot;,&quot;
precision       ::=  digit
type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="推导式" tabindex="-1"><a class="header-anchor" href="#推导式" aria-hidden="true">#</a> 推导式</h3><p>通过字符串, 从一个数据序列构建另一个序列, 可以被 <code>input</code> 函数解析或直接使用表示变量的值</p><h4 id="列表推导式" tabindex="-1"><a class="header-anchor" href="#列表推导式" aria-hidden="true">#</a> 列表推导式</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>res <span class="token operator">=</span> <span class="token punctuation">[</span>out_exp_res <span class="token keyword">for</span> out_exp <span class="token keyword">in</span> input_list <span class="token keyword">if</span> condition<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>res 结果列表</li><li>out_exp_res 遍历列表元素的表达式, 返回值作为列表元素</li><li>out_exp 表达式中的迭代变量</li><li>input_list 输入列表(可迭代类型)</li><li>condition 迭代变量满足条件</li></ol><ul><li>eg. 过滤掉长度小于或等于 3 的字符串列表, 并将剩下的转换成大写字母</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token operator">*</span> new_names <span class="token operator">=</span> <span class="token punctuation">[</span>it<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> it <span class="token keyword">in</span> names <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>注意, 输入列表也可以是返回列表的函数, 如 range()</li></ul><h4 id="字典推导式" tabindex="-1"><a class="header-anchor" href="#字典推导式" aria-hidden="true">#</a> 字典推导式</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>res <span class="token operator">=</span> <span class="token punctuation">{</span> key_expr<span class="token punctuation">:</span> value_expr <span class="token keyword">for</span> value <span class="token keyword">in</span> collection <span class="token keyword">if</span> condition <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>res 结果字典</li><li>key_expr 遍历列表元素的表达式, 返回值作为键名</li><li>value_expr 遍历列表元素的表达式, 返回值作为键值</li><li>value 表达式中的迭代变量</li><li>collection 输入列表(可迭代类型)</li><li>condition 迭代变量满足条件</li></ol><ul><li>eg. 使用字符串及其长度创建字典</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>newdict <span class="token operator">=</span> <span class="token punctuation">{</span>key<span class="token punctuation">:</span><span class="token builtin">len</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">for</span> key <span class="token keyword">in</span> listdemo<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="集合推导式" tabindex="-1"><a class="header-anchor" href="#集合推导式" aria-hidden="true">#</a> 集合推导式</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>res <span class="token operator">=</span> <span class="token punctuation">{</span> expression <span class="token keyword">for</span> item <span class="token keyword">in</span> Sequence <span class="token keyword">if</span> conditional <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>与列表相同, 使用 {} 包裹</p><h4 id="元组推导式" tabindex="-1"><a class="header-anchor" href="#元组推导式" aria-hidden="true">#</a> 元组推导式</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>res <span class="token operator">=</span> <span class="token punctuation">(</span>expression <span class="token keyword">for</span> item <span class="token keyword">in</span> Sequence <span class="token keyword">if</span> conditional <span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>与列表相同, 使用 () 包裹<br><mark>注意元组推导式返回的是生成器对象, 不是元组</mark><br> 生成器对象不直接保存数据, 而是在迭代时计算结果<br> 需要使用方法 <code>res = tuple([生成器])</code> 生成元组<br> 例如 <code>name_list = tuple(name_list[key] for key in bind_enum.__members__.keys())</code></p><h4 id="分支推导式" tabindex="-1"><a class="header-anchor" href="#分支推导式" aria-hidden="true">#</a> 分支推导式</h4><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>res <span class="token operator">=</span> <span class="token punctuation">[</span>结果<span class="token number">1</span> <span class="token keyword">if</span> 判断条件 <span class="token keyword">else</span> 结果<span class="token number">2</span> <span class="token keyword">for</span> 变量名 <span class="token keyword">in</span> 原列表<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,32);function J(Q,Z){const e=t("ExternalLinkIcon"),l=t("RouterLink");return i(),p("div",null,[r,n("p",null,[a("参考教程 "),n("a",k,[a("https://docs.python.org/zh-cn/3/tutorial/index.html"),s(e)])]),h,n("ul",null,[m,n("li",null,[a("对于一般 Python 对象与容器 "),n("ul",null,[n("li",null,[a("参见内置模块 "),n("a",v,[a("pickle"),s(e)])])])])]),b,n("p",null,[a("参考 "),n("a",E,[a("https://www.runoob.com/w3cnote/python-func-decorators.html"),s(e)])]),f,n("ul",null,[y,g,n("li",null,[_,a(" 打印异常的位置 "),n("ul",null,[B,n("li",null,[a("传入"),s(l,{to:"/coding/py/base/module.html#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"},{default:d(()=>[a("文件对象")]),_:1}),a("或文件路径字符串, 将打印到文件中")])])]),x]),A,n("ul",null,[w,n("li",null,[a("使用两个下划线 "),q,a(" 为前缀表示类的私有变量时, 将使用 "),F,a(" 代替 "),C,n("ul",null,[D,P,n("li",null,[a("该方法也可以防止子类中定义了同名的函数导致父类函数被覆盖, 使父类出错的情况, 可参考例子 "),n("a",N,[a("https://docs.python.org/zh-cn/3/tutorial/classes.html#private-variables"),s(e)])])])])]),T,n("p",null,[a("参考自 "),n("a",z,[a("https://docs.python.org/zh-cn/3/tutorial/classes.html#inheritance"),s(e)])]),L,n("ul",null,[n("li",null,[a("模拟容器类型 "),n("a",R,[a("https://docs.python.org/zh-cn/3/reference/datamodel.html#emulating-container-types"),s(e)])]),n("li",null,[a("模拟数学类型 "),n("a",I,[a("https://docs.python.org/zh-cn/3/reference/datamodel.html#emulating-numeric-types"),s(e)])]),n("li",null,[a("资源管理类 "),n("a",j,[a("https://docs.python.org/zh-cn/3/reference/datamodel.html#with-statement-context-managers"),s(e)]),H,a(" 用于配合 "),S,a(" 语句使用")])]),U,n("p",null,[a("参考文档 "),n("a",V,[a("https://docs.python.org/zh-cn/3/howto/enum.html"),s(e)])]),G,n("p",null,[a("格式化字符串的表示方法如下"),X,a(" 参考自"),W,n("a",O,[a("http://www.cppcns.com/jiaoben/python/287553.html"),s(e)]),Y,n("a",K,[a("https://zhuanlan.zhihu.com/p/295621558"),s(e)])]),M])}const an=c(u,[["render",J],["__file","base.html.vue"]]);export{an as default};
