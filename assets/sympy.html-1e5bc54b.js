import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as t,c as i,b as s,d as l,a as e,w as m,e as a}from"./app-8c5ce49e.js";const r={},p=s("h1",{id:"sympy-笔记",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#sympy-笔记","aria-hidden":"true"},"#"),l(" Sympy 笔记")],-1),h=s("p",null,[l("默认使用 "),s("code",null,"import sympy as sy"),l(" 导入 Sympy")],-1),u={href:"https://docs.sympy.org/latest/index.html",target:"_blank",rel:"noopener noreferrer"},y=a('<h2 id="表达式的基本操作" tabindex="-1"><a class="header-anchor" href="#表达式的基本操作" aria-hidden="true">#</a> 表达式的基本操作</h2><h3 id="构建表达式" tabindex="-1"><a class="header-anchor" href="#构建表达式" aria-hidden="true">#</a> 构建表达式</h3><p>Sympy 中以变量符号对象为基础构建表达式</p><ul><li><code>x = sy.symbol(a)</code> 创建变量符号 <ul><li><code>a</code> 字符串, 表示创建变量的符号, 可使用空格分隔创建多个变量 <ul><li>使用 <code>x:m</code> 则可创建 <code>x0</code> 到 <code>xm-1</code> 共 <code>m</code> 个带有标号的变量</li><li>使用 <code>x:m:n</code> 则可创建 <code>x00</code> 到 <code>xm-1n-1</code> 共 <code>m * n</code> 个带有标号的变量</li><li>变量符号与接收变量符号对象的变量不一定要同名</li><li>变量符号名称中没有空格即可, 因此可使用 <code>\\\\theta_{1,2}</code> 等 Latex 符号表示作为符号名称, 方便将<a href="#%E6%89%93%E5%8D%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式导出为 Laxte</a></li></ul></li><li>返回值为变量符号对象, 如果创建多个则为变量符号对象组成的元组</li></ul></li><li><code>exp_res = sy.&lt;数学函数&gt;(exp)</code><ul><li><code>exp</code> 输入表达式, 变量符号或数值</li><li>返回值为一个以输入表达式为变量的数学函数表达式, 如果传入数值将得到一个不含变量的表达式</li><li>可用的数学函数有 <code>sin</code>, <code>cos</code>, <code>exp</code>, <code>log</code>, <code>sqrt</code>, 伽马函数 <code>gamma</code>, 阶乘 <code>factorial</code> 等</li></ul></li></ul><p>关于表达式还有如下说明</p><ul><li>表达式为 Python 对象, 可通过变量保存, 但表达式对象本身一般为不可变的, 只能通过表达式构造新的表达式</li><li>变量符号实际为一种特殊的表达式, 通过表达式之间的数学运算即可构造新的表达式</li><li>构造表达式时, Sympy 只会进行最低程度的化简, 如 <ul><li>加减法中, 直接减去已有项, 如 <code>x + y - x = y</code></li><li>乘除法中, 直接消去公因式, 如 <code>x * y / x = y</code></li><li>尝试将含数值的表达式转换为最简形式, 如 <code>sy.sqrt(8 * x) = 2 * sqrt(2) * sqrt(x)</code></li><li>对于将表达式化简为特定形式见<a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%96%E7%AE%80">表达式化简</a>部分</li></ul></li></ul><h3 id="表达式操作" tabindex="-1"><a class="header-anchor" href="#表达式操作" aria-hidden="true">#</a> 表达式操作</h3><p>通过表达式对象的方法可对表达式进行操作</p><ul><li>变量代换 <code>expr.subs(old, new)</code> / <code>expr.subs(dicts)</code><ul><li><code>old</code> 表达式 <code>expr</code> 中的变量符号对象或表达式 (传入表达式时将尝试从当前被修改表达式中匹配)</li><li><code>new</code> 用于代换的表达式或数值</li><li><code>dicts</code> 一个以变量符号对象为键, 代换表达式为值的字典, 通过该方法可一次代换多个参数</li><li>返回值为一个新的表达式式, 即使所有变量都代换为数值, 得到的依然为表达式对象</li></ul></li><li>计算表达式的值 <code>expr.evalf(n = 15, subs = None, maxn = 100, chop = False)</code><ul><li><code>n</code> 计算结果的精度</li><li><code>subs</code> 一个以变量符号对象为键, 变量数值为值的字典, 表示计算表达式时各个变量的值, 如果表达式中没有变量可直接传入 <code>None</code></li><li><code>maxn</code> 计算表达式值时允许的最大精度</li><li><code>chop</code> 传入 <code>False</code> 表示不忽略任何数值, 传入数值表示允许忽略比传入值小的量</li></ul></li><li>尝试将字符串转换为表达式 <code>expr = sy.sympify(str)</code><ul><li><code>str</code> 表达式字符串</li><li>返回值为转换的表达式, 如果要操作表达式中的变量应当使用 <code>sy.symbols</code> 创建对应名称的变量</li></ul></li><li>将表达式封装为 Python 函数 <code>sy.lambdify(/, args, exprs, modules)</code><ul><li><code>args</code> 单个变量符号或变量符号列表, 表示函数接收参数对应的变量</li><li><code>exprs</code> 用于封装的表达式对象, 当传入表达式列表时, 封装的函数将返回一个列表表示各个表达式的值</li><li><code>modules</code> 封装中数学函数的实现模块, 使用字符串表示, 常用的有 <ul><li><code>numpy</code> 封装中使用 Numpy 模块的数学函数, 此时可对函数传入 Numpy 数组</li><li><code>math</code> 封装中使用 math 模块的数学函数</li></ul></li></ul></li></ul><h3 id="打印表达式" tabindex="-1"><a class="header-anchor" href="#打印表达式" aria-hidden="true">#</a> 打印表达式</h3><p>希望 Sympy 打印表达式前, 需要先调用函数 <code>sy.init_printing()</code> 进行初始化<br> 以下为常用的打印表达式函数</p>',11),x=s("li",null,[l("美化输出表达式 "),s("code",null,"sy.pprint(expr)"),s("ul",null,[s("li",null,[s("code",null,"expr"),l(" 用于打印的表达式")]),s("li",null,"该函数将向终端打印美化的表达式输出")])],-1),g=s("code",null,"sy.latex(expr, *)",-1),_=s("li",null,[s("code",null,"expr"),l(" 用于打印的表达式")],-1),f=s("li",null,"该函数将返回表达式的 Latex 形式的字符串",-1),w={href:"https://docs.sympy.org/latest/modules/printing.html#module-sympy.printing.latex",target:"_blank",rel:"noopener noreferrer"},b=s("ul",null,[s("li",null,[s("code",null,"full_prec = False"),l(" 是否将小数转为分数表示")]),s("li",null,[s("code",null,"diff_operator = 'd'"),l(" 微分算子的字体, 默认为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"d")]),s("annotation",{encoding:"application/x-tex"},"d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"d")])])]),l(", 使用参数 "),s("code",null,"md"),l(" 时表示 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"d")]),s("annotation",{encoding:"application/x-tex"},"\\mathrm{d}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathrm"},"d")])])])]),s("li",null,[s("code",null,"mat_symbol_style = 'plain'"),l(" 矩阵变量的字体, 默认为一般字体 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"A")]),s("annotation",{encoding:"application/x-tex"},"A")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal"},"A")])])]),l(", 使用参数 "),s("code",null,"bold"),l(" 时表示 "),s("code",null,"\\mathbf{A}")]),s("li",null,[s("code",null,"ln_notation = False"),l(" 对数函数表示, 默认为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("annotation",{encoding:"application/x-tex"},"\\log")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),s("span",{class:"mop"},[l("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")])])])]),l(", 使用 "),s("code",null,"True"),l(" 时为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"ln"),s("mo",null,"⁡")]),s("annotation",{encoding:"application/x-tex"},"\\ln")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mop"},"ln")])])])]),s("li",null,[s("code",null,"inv_trig_style = 'abbreviated'"),l(" 反三角函数表示, 默认为缩写如 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mstyle",{mathcolor:"#cc0000"},[s("mtext",null,"\\asin")])]),s("annotation",{encoding:"application/x-tex"},"\\asin")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord text",style:{color:"#cc0000"}},[s("span",{class:"mord",style:{color:"#cc0000"}},"\\asin")])])])]),l(", 使用 "),s("code",null,"full"),l(" 时为全称如 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"arcsin"),s("mo",null,"⁡")]),s("annotation",{encoding:"application/x-tex"},"\\arcsin")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6679em"}}),s("span",{class:"mop"},"arcsin")])])])]),s("li",null,[s("code",null,"parenthesize_super = True"),l(" 当表达式被用于幂运算时, 加上括号")]),s("li",null,[s("code",null,"fold_func_brackets = False"),l(" 允许时省略函数的括号")])],-1),v=a('<h3 id="其他说明" tabindex="-1"><a class="header-anchor" href="#其他说明" aria-hidden="true">#</a> 其他说明</h3><ul><li>实用操作 <ul><li><code>expr.coeff(x, n)</code> 提取系数 <ul><li><code>x</code> 用于分析的变量符号</li><li><code>n</code> 提取系数项的幂次</li><li>返回结果为一个表达式, 即被提取的系数</li></ul></li></ul></li><li>特殊符号的表示 <ul><li>无穷 <code>sy.oo</code></li><li>虚数单位 <code>sy.I</code></li></ul></li></ul><h2 id="表达式化简" tabindex="-1"><a class="header-anchor" href="#表达式化简" aria-hidden="true">#</a> 表达式化简</h2><p>通过调用 Sympy 模块的函数, 可对表达式进行进一步化简</p><p>对于一般情况, 函数 <code>sy.simplify(expr)</code> 将尝试使输入表达式 <code>expr</code> 化简为最简的形式, 并进行一些必要的函数代换如 <code>cos(x) ** 2 + sin(x) ** 2 = 1</code></p><p>对于其他的化简需求, 可使用以下化简函数</p><h3 id="多项式化简" tabindex="-1"><a class="header-anchor" href="#多项式化简" aria-hidden="true">#</a> 多项式化简</h3><p>以下化简方法以多项式为核心进行, 将其他函数视为系数</p><ul><li><code>sy.expand(expr)</code> 展开为多项式之和</li><li><code>sy.factor(expr)</code> 化简为多项式因式</li><li><code>sy.collect(expr, x, *, exact = False)</code> 以指定变量 <code>x</code> 将表达式整理为关于该变量的各次幂与系数的多项式之和 <ul><li><code>expr</code> 被整理的表达式</li><li><code>x</code> 用于整理系数的变量, 表达式或表达式列表</li><li><code>exact</code> 为 <code>True</code> 时, 整理时将仅提取关于指定变量的因数, 而不包含其它次幂</li><li>如选择变量 <code>x</code> 将表达式整理为类似 <code>a * x ** 2 + b * x + c</code> 的形式 (其中 <code>x</code> 可以是表达式或表达式列表)</li></ul></li><li><code>sy.cancel(expr)</code> 整理为多项式之和的分式 <ul><li>对于含除法的多项式可使用该函数</li><li>对于多项式因式的分式使用 <code>sy.factor(expr)</code> 即可</li></ul></li><li><code>sy.apart(expr)</code> 整理为多项式分式之和</li></ul><h3 id="其他化简函数" tabindex="-1"><a class="header-anchor" href="#其他化简函数" aria-hidden="true">#</a> 其他化简函数</h3>',10),E=s("li",null,[l("三角函数化简"),s("br"),l(" 以下化简方法以三角函数为核心进行 (同样适用于双曲三角函数) "),s("ul",null,[s("li",null,[s("code",null,"sy.trigsimp(expr)"),l(" 将表达式中所有类型的三角函数转化为单一类型"),s("br"),l(" 该函数也倾向于将表达式整理到三角函数的变量内, 如 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mrow",null,[s("mi",null,"cosh"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("msup",null,[s("mrow",null,[s("mi",null,"sinh"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mi",null,"cosh"),s("mo",null,"⁡"),s("mo",{stretchy:"false"},"("),s("mn",null,"2"),s("mi",null,"x"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\cosh^2(x) + \\sinh^2(x)=\\cosh(2x)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.1484em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},[s("span",{class:"mop"},"cosh"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8984em"}},[s("span",{style:{top:"-3.1473em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.1484em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},[s("span",{class:"mop"},"sinh"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8984em"}},[s("span",{style:{top:"-3.1473em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},"cosh"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"2"),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")")])])])]),s("li",null,[s("code",null,"sy.expand_trig(expr)"),l(" 将表达式中的三角函数整理为简单变量的形式如 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"sin"),s("mo",null,"⁡"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",null,"+"),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mi",null,"sin"),s("mo",null,"⁡"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{stretchy:"false"},")"),s("mi",null,"cos"),s("mo",null,"⁡"),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mi",null,"sin"),s("mo",null,"⁡"),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mi",null,"cos"),s("mo",null,"⁡"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\sin(x + y) = \\sin(x)\\cos(y) + \\sin(y)\\cos(x)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},"sin"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},"sin"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},"cos"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},"sin"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},"cos"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")")])])])])])],-1),k=s("li",null,[l("乘方表达式化简 "),s("ul",null,[s("li",null,[s("code",null,"sy.powsimp(expr)"),l(" 将乘方表达式之间的乘法整理为单个乘方表达式")])])],-1),B=s("li",null,[l("对数表达式化简 "),s("ul",null,[s("li",null,[s("code",null,"sy.logcombine(expr)"),l(" 将多个对数表达式的运算整理为单个对数表达式")]),s("li",null,[s("code",null,"sy.expand_log(expr)"),l(" 将表达式中的对数整理为简单变量的形式")])])],-1),M={href:"https://docs.sympy.org/latest/tutorials/intro-tutorial/simplification.html",target:"_blank",rel:"noopener noreferrer"},A=s("li",null,[l("如果希望从方程组中分离出特定变量的表达式, 应该考虑使用"),s("a",{href:"#%E4%BB%A3%E6%95%B0%E6%96%B9%E7%A8%8B"},"代数方程求解 sy.solve()"),l(" 的方式实现")],-1),z=a('<h2 id="表达式运算" tabindex="-1"><a class="header-anchor" href="#表达式运算" aria-hidden="true">#</a> 表达式运算</h2><p>Sympy 中使用 <a href="#%E5%85%B6%E4%BB%96%E8%AF%B4%E6%98%8E">sy.oo</a> 表示无穷大</p><h3 id="求导" tabindex="-1"><a class="header-anchor" href="#求导" aria-hidden="true">#</a> 求导</h3><ul><li>计算表达式求导结果 <code>sy.diff(expr, *symbols)</code><ul><li><code>expr</code> 被求导的表达式</li><li><code>*symbols</code> 按传入的符号顺序对表达式进行求导 <ul><li>只传入变量符号对象时, 将按传入顺序分别求导</li><li>可以传入元组 <code>(sym, n)</code>, 表示对符号 <code>sym</code> 求导 <code>n</code> 次</li></ul></li></ul></li><li>构造带求导算子的表达式 <code>sy.Derivative(expr, *symbols)</code><ul><li>参数含义同 <code>sy.diff(expr, *symbols)</code></li><li>该函数仅构造表达式而不执行运算, 可调用表达式方法 <code>expr.doit()</code> 执行其中的运算</li></ul></li></ul><h3 id="积分" tabindex="-1"><a class="header-anchor" href="#积分" aria-hidden="true">#</a> 积分</h3>',5),L=s("ul",null,[s("li",null,[l("表达式积分结果 "),s("code",null,"sy.integrate(expr, **args)"),s("ul",null,[s("li",null,[s("code",null,"expr"),l(" 被积分的表达式")]),s("li",null,[s("code",null,"args"),l(" 按传入积分参数顺序对表达式进行多重积分 "),s("ul",null,[s("li",null,[l("只传入变量符号对象时, 将对该符号进行不定积分 (不包含常数 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"C")]),s("annotation",{encoding:"application/x-tex"},"C")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C")])])]),l(")")]),s("li",null,[l("可以传入元组 "),s("code",null,"(sym, lower_limit, upper_limit)"),l(", 表示对符号 "),s("code",null,"sym"),l(" 以上限 "),s("code",null,"lower_limit"),l(" 与下限 "),s("code",null,"upper_limit"),l(" 进行定积分")])])])])]),s("li",null,[l("构造带积分算子的表达式 "),s("code",null,"sy.Integral(expr, **args)"),s("ul",null,[s("li",null,[l("参数含义同 "),s("code",null,"sy.integrate(expr, **args)")]),s("li",null,[l("该函数仅构造表达式而不执行运算, 可调用表达式方法 "),s("code",null,"expr.doit()"),l(" 执行其中的运算")])])])],-1),F=s("h3",{id:"其他运算",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#其他运算","aria-hidden":"true"},"#"),l(" 其他运算")],-1),C=a("<li>表达式极限 <code>sy.limit(e, z, z0, dir = &#39;+&#39;)</code><ul><li><code>e</code> 被求极限的表达式</li><li><code>z</code> 极限变量</li><li><code>z0</code> 逼近的常量</li><li><code>+</code> 求正方向邻域的极限 (如果求负方向邻域的极限则传入 <code>-</code>)</li><li>类似有 <code>sy.Limit(e, z, z0, dir = &#39;+&#39;)</code> 构造带极限算子的表达式</li></ul></li><li>泰勒级数展开 <code>sy.series(expr, x, x0, n = 6, dir = &#39;+&#39;)</code><ul><li><code>expr</code> 被泰勒展开的表达式</li><li><code>x</code> 展开变量</li><li><code>x0</code> 展开位置</li><li><code>n</code> 展开阶数</li><li><code>dir</code> 逼近方向</li><li>返回值将带有该届无穷小表达式 <code>O(x**n)</code>, 可对返回的表达式使用 <code>expr.removeO()</code> 去除</li></ul></li>",2),q={href:"https://docs.sympy.org/latest/modules/series/fourier.html#fourier-series",target:"_blank",rel:"noopener noreferrer"},S={href:"https://docs.sympy.org/latest/tutorials/intro-tutorial/calculus.html#finite-differences",target:"_blank",rel:"noopener noreferrer"},N=a('<h2 id="方程求解" tabindex="-1"><a class="header-anchor" href="#方程求解" aria-hidden="true">#</a> 方程求解</h2><h3 id="代数方程" tabindex="-1"><a class="header-anchor" href="#代数方程" aria-hidden="true">#</a> 代数方程</h3><ul><li>构造等式方程 <code>sy.Eq(expr1, expr2)</code><ul><li><code>expr1</code> 等式左侧的表达式</li><li><code>expr2</code> 等式右侧的表达式</li><li>返回等式表达式</li><li>注意, Sympy 中不能使用 <code>=</code> 或 <code>==</code> 构造等式方程, 只能使用函数 <code>sy.Eq</code><br> 当非等式的表达式用于方程求解时, 将被视为等于 <code>0</code> 的方程</li></ul></li><li>以集合形式表示代数方程的解 <code>sy.solveset(/, equation, variable, domain = sy.S.Complex)</code><ul><li><code>equation</code> 用于求解的等式, 可传入等式列表表示方程组</li><li><code>variable</code> 方程中的待求变量, 可传放入变量对象元组, 表示多个待求变量</li><li><code>domain</code> 变量所在的域, 常用有 <code>sy.S.Real</code> 表示实数域, <code>sy.S.Complex</code> 表示复数域</li><li>该函数的返回值为集合, 如果有多个待求变量则返回向量的集合</li><li>使用该函数可用于得到代数方程解的严格表达式, 特别是多个解的情况, 但无法表示重根</li></ul></li><li>以表达式形式表示代数方程的解 <code>sy.solve(/, equation, variable, *, dict = False)</code><ul><li><code>equation</code> 用于求解的等式, 可传入等式列表表示方程组</li><li><code>variable</code> 方程中的待求变量, 可传放入变量对象元组, 表示多个待求变量 (即使仅需要从方程组中求出一个量, 也应该写入所有应消去的变量, 以此表明剩余的变量为不必消去的常量)</li><li><code>dict</code> 使用一个以待求变量为键, 解为值的字典表示解 (默认使用列表表示一组解, 列表的元素与传入的待求变量顺序对应)</li><li>该函数的返回值为各个解组成的列表 (即使只有一个解或无解), 即使方程有无数解, 该函数也仅返回部分解</li><li>该函数得到的解依然为表达式对象</li></ul></li><li>多项式方程求解 <code>sy.roots(/, equation, variable)</code><ul><li><code>equation</code> 用于求解的多项式方程</li><li><code>variable</code> 多项式方程变量</li><li>该函数的返回值为以方程的根为键, 方程根的重数为值的字典</li></ul></li><li>求解方程的数值解 <code>sy.nsolve(/, equation, x, x0 = None, *, dict = False)</code><ul><li><code>equation</code> 用于求解的等式, 可传入等式列表表示方程组</li><li><code>x</code> 方程中的待求变量, 可传放入变量对象元组, 表示多个待求变量</li><li><code>x0</code> 数值解的迭代起始值, 如果有多个起始值需要传入元组 (如果起始值为复数, 则将寻找复数解)</li><li><code>dict</code> 是否以字典的形式返回解, 类似 <code>sy.solve(dict = True)</code></li></ul></li></ul><h3 id="常微分方程" tabindex="-1"><a class="header-anchor" href="#常微分方程" aria-hidden="true">#</a> 常微分方程</h3>',4),D=s("li",null,[l("常微分方程中, 未知量为关于特定变量如 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"t")]),s("annotation",{encoding:"application/x-tex"},"t")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6151em"}}),s("span",{class:"mord mathnormal"},"t")])])]),l(" 的函数, 而不是一般的变量, 因此需要定义函数类型的变量对象 "),s("ul",null,[s("li",null,[l("首先创建函数表达式 "),s("code",null,"y = sy.symbols(a, cls = sy.Function)"),l(", 该函数即"),s("a",{href:"#%E6%9E%84%E5%BB%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F"},"构建表达式"),l("函数, 但具有一个额外的参数")]),s("li",null,[l("由于没有绑定函数的自变量, 因此创建的函数表达式并不完整, 需要使用 "),s("code",null,"y = y(t)"),l(" 将变量 "),s("code",null,"t"),l(" 绑定为函数 "),s("code",null,"y"),l(" 的自变量 (允许绑定多个变量表示多元函数类型的变量对象)")]),s("li",null,[l("函数类型的变量对象的导数将保留微分算子, 因此两种"),s("a",{href:"#%E6%B1%82%E5%AF%BC"},"求导方法"),l("没有区别"),s("br"),l(" 表示微分方程时推荐使用 "),s("code",null,"sy.diff()"),l(" 如 "),s("code",null,"ypp = sy.diff(y, (t, 2))")])])],-1),X=s("li",null,[l("求解常微分方程的解析解 "),s("code",null,"sy.dsolve(/, equation, function, *, ics = None)"),s("ul",null,[s("li",null,[s("code",null,"equation"),l(" 用于求解的常微分方程, 可传入等式元组表示方程组")]),s("li",null,[s("code",null,"function"),l(" 方程中的待求函数, 可传放入函数类型变量对象元组, 表示多个待求函数")]),s("li",null,[s("code",null,"ics"),l(" 方程组的边界条件 "),s("ul",null,[s("li",null,[l("默认没有给出初值条件, 则结果中将包含待定系数 "),s("code",null,"Cx"),l(", 可先定义名称为 "),s("code",null,"Cx"),l(" 的变量符号再通过 "),s("a",{href:"#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C"},"expr.subs"),l(" 带入具体值")]),s("li",null,[l("可传入一个字典, 字典的键为关于函数的已知条件, 值为已知条件的值, 例如 "),s("code",null,"{f.diff(t).subs(0): 1}"),l(" 体现边界条件 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"f"),s("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")]),s("mo",{stretchy:"false"},"("),s("mn",null,"0"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"f'(0)=1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0019em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.7519em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"′")])])])])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"0"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])])])]),s("li",null,[l("函数的返回值为一个列表, 列表中的元素为各个待求函数的解 (等式形式), 其中函数在左侧, 函数表达式在右侧"),s("br"),l(" 通过等式对象的成员 "),s("code",null,"eq.rhs"),l(" 可访问右侧的表达式")])])],-1),R=s("a",{href:"#%E4%BB%A3%E6%95%B0%E6%96%B9%E7%A8%8B"},"sy.solve",-1),T={class:"katex"},I=s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mfrac",null,[s("mi",{mathvariant:"normal"},"d"),s("mrow",null,[s("mi",{mathvariant:"normal"},"d"),s("mi",null,"t")])]),s("mover",{accent:"true"},[s("mi",null,"X"),s("mo",null,"⃗")]),s("mo",null,"="),s("mi",null,"F"),s("mo",{stretchy:"false"},"("),s("mover",{accent:"true"},[s("mi",null,"X"),s("mo",null,"⃗")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\frac{\\mathrm{d}}{\\mathrm{d}t}\\vec{X}=F(\\vec{X})")])])],-1),V={class:"katex-html","aria-hidden":"true"},P={class:"base"},H=a('<span class="strut" style="height:1.3113em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">d</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span>',2),O={class:"mord accent"},Y={class:"vlist-t"},j={class:"vlist-r"},G={class:"vlist",style:{height:"0.9663em"}},J=s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07847em"}},"X")],-1),K={style:{top:"-3.2523em"}},Q=s("span",{class:"pstrut",style:{height:"3em"}},null,-1),U={class:"accent-body",style:{left:"-0.1522em"}},W={class:"overlay",style:{height:"0.714em",width:"0.471em"}},Z={xmlns:"http://www.w3.org/2000/svg",width:"0.471em",height:"0.714em",style:{width:"0.471em"},viewBox:"0 0 471 714",preserveAspectRatio:"xMinYMin"},$=s("path",{d:`M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`},null,-1),ss=[$],ls=s("span",{class:"mspace",style:{"margin-right":"0.2778em"}},null,-1),es=s("span",{class:"mrel"},"=",-1),as=s("span",{class:"mspace",style:{"margin-right":"0.2778em"}},null,-1),ns={class:"base"},ts=s("span",{class:"strut",style:{height:"1.2163em","vertical-align":"-0.25em"}},null,-1),is=s("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"F",-1),os=s("span",{class:"mopen"},"(",-1),cs={class:"mord accent"},ds={class:"vlist-t"},ms={class:"vlist-r"},rs={class:"vlist",style:{height:"0.9663em"}},ps=s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07847em"}},"X")],-1),hs={style:{top:"-3.2523em"}},us=s("span",{class:"pstrut",style:{height:"3em"}},null,-1),ys={class:"accent-body",style:{left:"-0.1522em"}},xs={class:"overlay",style:{height:"0.714em",width:"0.471em"}},gs={xmlns:"http://www.w3.org/2000/svg",width:"0.471em",height:"0.714em",style:{width:"0.471em"},viewBox:"0 0 471 714",preserveAspectRatio:"xMinYMin"},_s=s("path",{d:`M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`},null,-1),fs=[_s],ws=s("span",{class:"mclose"},")",-1),bs=s("li",null,[l("利用 "),s("a",{href:"#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C"},"sy.lambdify"),l(" 构造 Python 函数, 其中参数 "),s("code",null,"exprs"),l(" 为一个列表, 对应了各阶导数的表达式")],-1),vs=s("h2",{id:"矩阵运算",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#矩阵运算","aria-hidden":"true"},"#"),l(" 矩阵运算")],-1);function Es(ks,Bs){const n=o("ExternalLinkIcon"),c=o("RouterLink");return t(),i("div",null,[p,h,s("p",null,[l("参考教程 "),s("a",u,[l("https://docs.sympy.org/latest/index.html"),e(n)])]),y,s("ul",null,[x,s("li",null,[l("获取 Latex 形式的表达式 "),g,s("ul",null,[_,f,s("li",null,[l("通过传入参数可对样式进行设置, 以下为常用设置, 更多见"),s("a",w,[l("官方文档"),e(n)]),b])])])]),v,s("ul",null,[E,k,B,s("li",null,[l("其他化简函数参考"),s("a",M,[l("官方文档"),e(n)])]),A]),z,L,F,s("ul",null,[C,s("li",null,[l("傅里叶级数展开 见"),s("a",q,[l("官方文档"),e(n)])]),s("li",null,[l("有限差分 见"),s("a",S,[l("官方文档"),e(n)])])]),N,s("ul",null,[D,X,s("li",null,[l("求解常微分方程的数值解 "),s("ul",null,[s("li",null,[l("利用 "),R,l(" 构造 "),s("span",T,[I,s("span",V,[s("span",P,[H,s("span",O,[s("span",Y,[s("span",j,[s("span",G,[J,s("span",K,[Q,s("span",U,[s("span",W,[(t(),i("svg",Z,ss))])])])])])])]),ls,es,as]),s("span",ns,[ts,is,os,s("span",cs,[s("span",ds,[s("span",ms,[s("span",rs,[ps,s("span",hs,[us,s("span",ys,[s("span",xs,[(t(),i("svg",gs,fs))])])])])])])]),ws])])]),l(" 的常微分方程组")]),bs,s("li",null,[l("利用 Scipy 中的函数 "),e(c,{to:"/coding/py/math/scipy.html#%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B8%8E%E7%A7%AF%E5%88%86"},{default:m(()=>[l("scipy.integrate.solve_ivp")]),_:1}),l(" 求出数值解")])])])]),vs])}const zs=d(r,[["render",Es],["__file","sympy.html.vue"]]);export{zs as default};
