import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as a,e}from"./app-8c5ce49e.js";const S={},r=e('<h1 id="通信协议-spi" tabindex="-1"><a class="header-anchor" href="#通信协议-spi" aria-hidden="true">#</a> 通信协议 SPI</h1><h2 id="外设介绍" tabindex="-1"><a class="header-anchor" href="#外设介绍" aria-hidden="true">#</a> 外设介绍</h2><h3 id="物理层" tabindex="-1"><a class="header-anchor" href="#物理层" aria-hidden="true">#</a> 物理层</h3><ol><li>NSS/CS 从设备选择器 用于选择从设备, 主机上的 1SS 对应从机 1 上的 CS, 2SS 对应从机 2 上的 CS, 主机 NSS 的选择无要求</li><li>SCK 时钟信号线 由主设备产生, 通信速率受限于低速设备</li><li>MOSI(Master Output Slave Input) 主设备输出/从设备输入引脚</li><li>MISO(Master Input Slave Output) 主设备输入/从设备输出引脚</li></ol><h3 id="协议层" tabindex="-1"><a class="header-anchor" href="#协议层" aria-hidden="true">#</a> 协议层</h3><ol><li>从机选择 NSS 为低电平时, 表示从机被选中, 一次只选择一个从机</li><li>数据传输 在 SCK 的一个时钟周期里, MISO 于 MOSI 传输一个 bit</li><li>起始/终止信号 NSS 信号由高变低即通信开始, NSS 由底变高即结束</li><li>SPI 通常采用 MSB first(most significant bit), 即先传输二进制数据的最高位</li><li>时钟极性 CPOL 空闲状态时, SCK 的电平 CPOL = 0 时, SCK 在空闲时为低电平</li><li>时钟相位 CPHA 数据采样时刻 CPHA = 0 时, 信号将会在 SCK 的奇数边沿采样(边沿从 1 开始计)</li><li>数据传输 以 CPHA = 0, CPOL = 0 为例 通信开始后, SCK 首先由低电平变为高点平, 在第一个边沿时(奇数), MOSI 与 MISO 的信号被采样; SCK 然后由高电平变为低电平, 不被采样, 再次变化后被采样</li></ol><ul><li>当 NSS 电平切换后(通信开始又结束), 之前的状态不会保留, 输出的信息将丢失, 因此<mark>写入后必须立即读取, 且不能改变 NSS</mark></li></ul><h3 id="stm32-spi-通信过程" tabindex="-1"><a class="header-anchor" href="#stm32-spi-通信过程" aria-hidden="true">#</a> STM32 SPI 通信过程</h3><ol><li>NSS 产生起始信号</li><li>将数据写入数据寄存器 DR, 存入缓冲区</li><li>SCK 开始运行, MOSI 传输出缓冲区中的数据, MISO 结束数据存入缓冲区</li><li>数据传输完成后, TXE(TX empty) 置为 1; 数据接收完成后, RXNE(RX not empty) 置为 1</li><li>TX 为 1 后, 再次存入数据即可继续传输; RXNE 为 1 后, 读取数据后即可继续读取</li></ol><h2 id="库函数配置" tabindex="-1"><a class="header-anchor" href="#库函数配置" aria-hidden="true">#</a> 库函数配置</h2><h3 id="spi-初始化结构体" tabindex="-1"><a class="header-anchor" href="#spi-初始化结构体" aria-hidden="true">#</a> SPI 初始化结构体</h3><ol><li>SPI_Direction 设置 SPI 的通信方向, 一般为 2Line_FullDuplex(全双工)</li><li>SPI_Mode 工作模式 Master 主机, Slave 从机</li><li>SPI_DataSize 数据帧的大小, 8b 8 位; 16b 16 位</li><li>SPI_CPOL CPOL_Low 设置 CPOL = 0; CPOL_High 设置 CPOL = 1;</li><li>SPI_CPHA 1Edge 沿奇数沿采样; 2Edge 沿偶数沿采样</li><li>SPI_NSS Hard 硬件模式, 只有一个 NSS 引脚; Soft 软件模式, 即通过手动设置 GPIO 实现 NSS 的控制, 可以同时控制多个</li><li>SPI_FirstBit 设置使用 MSB First 或 LSB First, 通常为 MSB First</li><li>SPI_CRCPolynomial CRC 校验多项式</li><li>SPI_BaudRatePrescaler SPI 相对于所在桥时钟的分频因子, 可设置为 2, 4, 8,至 256 分频</li></ol><h3 id="spi-库函数功能" tabindex="-1"><a class="header-anchor" href="#spi-库函数功能" aria-hidden="true">#</a> SPI 库函数功能</h3><ol><li>使用函数 SPI_I2S_GetFlagStatus 获取标识</li><li>SPI_I2S_FLAG_TXE 发送寄存器已空</li><li>SPI_I2S_FLAG_RXNE 接收寄存器非空</li><li>SPI_I2S_SendData(SPIx, DATA) 发送数据</li><li>SPI_I2S_ReceiveData(SPIx) 接收数据 与发送数据必须在同一个 CS 周期中</li></ol><h2 id="踩坑笔记" tabindex="-1"><a class="header-anchor" href="#踩坑笔记" aria-hidden="true">#</a> 踩坑笔记</h2><ol><li>读取数据的同时接收数据</li><li>使用 SPI 外设时, 即使不发送数据, 也要发送 0xFF, 否则无法读到数据</li><li>LL 使用 SPI 前需要先调用函数 LL_SPI_Enable</li><li>全双工模式下, 写入后必须马上读取</li></ol>',16),t=[r];function h(d,s){return l(),a("div",null,t)}const I=i(S,[["render",h],["__file","SPI.html.vue"]]);export{I as default};
