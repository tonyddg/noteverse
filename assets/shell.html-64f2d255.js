import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as t,c as r,b as e,d as l,a as d,w as a,e as o}from"./app-8c5ce49e.js";const h={},u=e("h1",{id:"shell-笔记",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#shell-笔记","aria-hidden":"true"},"#"),l(" Shell 笔记")],-1),p={href:"https://www.runoob.com/linux/linux-tutorial.html",target:"_blank",rel:"noopener noreferrer"},b=o('<h2 id="shell-基本介绍" tabindex="-1"><a class="header-anchor" href="#shell-基本介绍" aria-hidden="true">#</a> Shell 基本介绍</h2><p>Shell 是一种用于访问系统内核服务的应用程序<br> 实际上 Windows Explorer 属于一种图形界面的 Shell 程序</p><p>而在 Linux 中的 Shel 程序如 bahs, 主要使用命令的方式交互<br> 其中用于控制 Shell 完成功能的命令语言也是编程语言则称为 Shell 脚本<br> 以下 Shell 笔记以介绍 bash 下的 Shell 脚本的编写为主</p><h3 id="shell-程序" tabindex="-1"><a class="header-anchor" href="#shell-程序" aria-hidden="true">#</a> Shell 程序</h3><p>在 Linux 中, 常用的 Shell 程序有</p><ul><li>sh 最基础的 shell, 解释器一般位于 <code>bin/sh</code> (注意该笔记中的部分语法可能不被 sh 支持)</li><li>bash 在 sh 基础上改进的 shell, 通常是 Linux 系统的默认解释器, 解释器一般位于 <code>bin/bash</code></li><li>zsh 功能更强大的 shell, 但一般额外需要安装, 语法与 bash 存在一定差异, 安装后解释器位于 <code>bin/zsh</code></li></ul><h3 id="shell-脚本" tabindex="-1"><a class="header-anchor" href="#shell-脚本" aria-hidden="true">#</a> Shell 脚本</h3><p>可以创建文本文件, 并在文本内写入 Shell 脚本供 Shell 程序解释并执行</p><p>约定 Shell 脚本的第一行为 <code>#!&lt;解释器路径&gt;</code><br> 通过该语句规定执行该脚本所用的解释器, 对于 php, python 等脚本同理</p><p>Shell 脚本文件的拓展名则无具体要求, 一般以该脚本使用的 Shell 程序为拓展名, 如 <code>.zsh</code>, <code>.sh</code> 等</p><h3 id="运行脚本" tabindex="-1"><a class="header-anchor" href="#运行脚本" aria-hidden="true">#</a> 运行脚本</h3><p>可通过以下四种方式执行脚本</p>',12),f=e("li",null,[l("通过指定的解释器执行脚本文件 "),e("code",null,"<解释器> <脚本文件路径>"),e("br"),l(" 注意应当前目录下的文件应当使用相对路径 "),e("code",null,"./<脚本文件名>")],-1),m=e("code",null,"<脚本文件路径>",-1),k=e("br",null,null,-1),_=o("<li>使用当前 Shell 环境执行脚本文件 <code>source &lt;脚本文件路径&gt;</code><ul><li>通常可以使用 <code>.</code> 代替 <code>source</code></li><li>以上两种方式都是在新终端中执行脚本, 但 <code>source</code> 语句是在当前终端执行脚本, 因此其中定义的变量都会被作为环境变量保留下来, 因此该语句一般用于执行终端的初始化脚本</li><li>此外也可将该语句用于 bash 脚本中, 类似于导入其他的 bash 脚本</li></ul></li><li>直接向 Shell 终端程序输入脚本, 如以下的 bash 脚本语句均可在 bash 终端下输入并运行, 此时<mark>需要使用 <code>;</code> 代替换行</mark></li>",2),v=e("h3",{id:"基本语法",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#基本语法","aria-hidden":"true"},"#"),l(" 基本语法")],-1),g=e("p",null,[l("在 Shell 脚本中, 使用 "),e("code",null,"#"),l(" 作为单行注释"),e("br"),l(" 使用 "),e("code",null,": '"),l(" 作为注释开头, "),e("code",null,"'"),l(" 作为注释结尾, 实现多行注释")],-1),x=e("code",null,"if",-1),$=e("code",null,"程序路径 + 参数",-1),E=e("br",null,null,-1),w=o('<p>使用命令时注意</p><ul><li>当程序在环境变量 <code>PATH</code> 下时, 可直接输入程序名以执行这些程序, 对于绝大部分的 Linux 命令都是以方式执行的</li><li>否则需要给出程序的完整路径, 例如执行当前目录下的 python 脚本程序使用 <code>./script.py</code>, 运行 <code>bash</code> 程序使用 <code>/bin/bash</code></li><li>Shell 使用换行区分语句, 在终端中则可使用 <code>;</code> 代替换行, 因此 <code>&lt;命令1&gt;;&lt;命令2&gt;</code> 可在终端中执行多个命令</li></ul><p>在 bash 中, 最常使用的命令即 <code>echo &quot;&lt;字符串&gt;&quot;</code>, 该命令可向交互界面打印字符串</p><h2 id="变量" tabindex="-1"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h2><h3 id="变量定义" tabindex="-1"><a class="header-anchor" href="#变量定义" aria-hidden="true">#</a> 变量定义</h3><p>使用 <code>&lt;变量名&gt;=&lt;变量初值&gt;</code> 的语法即可定义一般变量</p><ul><li>定义变量时, <code>=</code> 两侧不应有空格, 否则可能导致错误</li><li>一般使用字母, 数字, 下划线的组合作为变量名 (不能以数字开头)</li><li>如果要定义常量, 则应在变量定义后, 使用 <code>readonly</code> 修饰变量, 且常量一般使用大写字母作为变量名</li><li>不建议在 bash 中使用浮点数与浮点运算, bash 仅会将这些数作为字符串处理</li><li>使用命令 <code>read &lt;变量名&gt;</code> 则将从控制台读取用户输入为变量赋值, 如果变量不存在将自动创建</li></ul><p>变量初值除了整数, 以及接下来介绍的字符串与数组, 可以使用 <code>$(命令)</code>, 此时将被包裹的内容视为脚本并运行, 然后将结果返回</p><ul><li>可使用此方法来获取查询命令的结果, 如 <code>a=$(pwd)</code> 可获取当前工作目录, <code>a=$(cat ${path})</code> 可读取 path 中的文件内容</li><li>在命令中使用 <code>${变量名}</code> 也将自动取变量值, 可使用此方法将变量值传入命令</li><li>语法 <code>`命令`</code> 与 <code>$(命令)</code> 效果相同, 笔记中以后者为主</li></ul><h3 id="使用变量" tabindex="-1"><a class="header-anchor" href="#使用变量" aria-hidden="true">#</a> 使用变量</h3>',10),A=e("li",null,[l("通过 "),e("code",null,"${<变量名>}"),l(" 即可访问变量的值 (一般情况下可省略大括号)")],-1),B=e("li",null,[l("对变量重新赋值的方式与变量定义相同, 不需要加 "),e("code",null,"${...}")],-1),S=e("li",null,[l("使用 "),e("code",null,"unset <变量名>"),l(" 即可删除指定名称的变量")],-1),y=e("li",null,[l("对于环境变量, 可使用 "),e("code",null,"$<变量名>"),l(" 的方式访问")],-1),F=e("code",null,"$0",-1),q=o("<li><code>${n}</code> 运行脚本时给出的第 n 个参数 (当 n 小于 10 时, 可省略大括号)</li><li><code>$#</code> 传递给脚本的参数数量</li><li><code>$?</code> 上一个命令的退出状态 (一般执行<mark>成功时为 <code>0</code>, 失败时为 <code>1</code> 或任意非零值</mark>)</li>",3),C=e("li",null,[l("使用命令 "),e("code",null,"declare -p <变量名>"),l(" 可以获取变量的类型与值信息")],-1),L=o('<h3 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h3><p>可以使用 <code>&#39;</code> 或 <code>&quot;</code> 包裹字符表示字符串, 但两者存在区别</p><ul><li>使用 <code>&#39;</code> 时, 不会对字符串内的内容做转换 (包括变量与转移字符)</li><li>使用 <code>&quot;</code> 时, 能解析 <code>${&lt;变量值&gt;}</code> 对应的变量值, 以及使用 <code>\\</code> 转义</li></ul><p>对于字符串变量 <code>str</code>, 可使用以下语法访问字符串的信息</p><ul><li><code>${#str}</code> 获取字符串的长度</li><li><code>${str:&lt;ind&gt;:&lt;size&gt;}</code> 获取字符串在索引 <code>ind</code> (从 0 开始索引) 及之后最多 <code>size</code> 个字符的子字符串<br> 当 <code>size = 1</code>, 即可以访问特定索引位置的字符</li><li><code>${str/&lt;str1&gt;/&lt;str2&gt;}</code> 将 <code>str</code> 中第一个匹配 <code>str1</code> 的子字符串替换为 <code>str2</code></li><li><code>${str//&lt;str1&gt;/&lt;str2&gt;}</code> 与上一个相同, 但该命令可以替换所有匹配的子字符串</li><li><code>${str/&lt;str1&gt;}</code> 将 <code>str</code> 中第一个匹配 <code>str1</code> 的子字符串删除</li><li><code>${str//&lt;str1&gt;}</code> 与上一个相同, 但该命令可以删除所有匹配的子字符串</li></ul><p>使用命令 <code>expr index &quot;${str}&quot; &lt;字符&gt;</code> 可用于查询字符在字符串中最早出现位置的索引<br> 如果希望保存结果, 则需要 <code>res=$(exper index &quot;${str}&quot; &lt;字符&gt;)</code><br> 对于其他字符串处理, 也可通过命令 <code>expr</code> 完成, 具体见 <code>expr --help</code></p><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h3><p>使用语法 <code>(元素1 元素2 ...)</code> 可以定义一个一维数组</p><ul><li>数组的索引从 0 开始</li><li>注意使用空格划分元素</li><li>bash 不支持多维数组</li></ul><p>使用语法 <code>declare -a &lt;变量名&gt;=([索引1]=元素1 [索引2]=元素2 ...)</code> 可以定义关联数组</p><ul><li>使用改语法时不一定要声明初值, 可以定义后再赋值</li></ul><p>修改数组时 (对于数组 <code>x</code> 为数组, 对于关联数组 <code>x</code> 为键)</p><ul><li>使用 <code>${arr[x]}</code> 访问数组 <code>arr</code> 的第 <code>x</code> 个元素</li><li>使用 <code>arr[x]=&lt;新值&gt;</code> 为数组第 <code>x</code> 个元素赋值, 如果对不存在的索引赋值则将自动创建, 因此数组的索引可能不连续</li><li>使用 <code>${arr[*]}</code> 获取数组内的所有元素, 通常使用此方法打印数组内的所有元素</li><li>使用 <code>${#arr[*]}</code> 获取数组的长度</li><li>使用 <code>${!arr[*]}</code> 获取数组所有有效的索引</li></ul><h2 id="运算" tabindex="-1"><a class="header-anchor" href="#运算" aria-hidden="true">#</a> 运算</h2><h3 id="数学运算" tabindex="-1"><a class="header-anchor" href="#数学运算" aria-hidden="true">#</a> 数学运算</h3><p>使用 <code>$[数学运算表达式]</code> 或 <code>$((数学运算表达式))</code> 表示数学运算 (注意 bash 仅支持整数运算)<br> 主要支持的运算有</p><ul><li><code>$[${a} + ${b}]</code> 相加</li><li><code>$[${a} - ${b}]</code> 相减</li><li><code>$[${a} * ${b}]</code> 相乘</li><li><code>$[${a} / ${b}]</code> 相除 (向下取整)</li><li><code>$[${a} % ${b}]</code> 取余</li></ul><p>如果希望计算浮点数与数学函数, 可能需要借助 <code>$()</code> 并执行如 <code>bc</code> 等计算指令</p><h3 id="关系运算" tabindex="-1"><a class="header-anchor" href="#关系运算" aria-hidden="true">#</a> 关系运算</h3><p>使用 <code>[[ 关系运算表达式 ]]</code> 表示关系运算 (注意 <code>[[]]</code> 与表达式之间要有空格)<br> 除了以上关系表达式, 也可使用 <code>test &lt;关系运算表达式&gt;</code><br> 当关系表达式被运算后, <mark>如果表达式成立</mark>, 则相当于命令执行成功, <mark>此时<a href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">特殊变量</a> <code>$?=0</code></mark>, 否则 <code>$?=1</code></p><p>对于多个关系运算, 可使用以下运算符进行连接</p><ul><li><code>!</code> 对运算结果取反</li><li><code>||</code> 逻辑或 (短路求值)</li><li><code>&amp;&amp;</code> 逻辑与 (短路求值)</li></ul><h3 id="数值关系运算" tabindex="-1"><a class="header-anchor" href="#数值关系运算" aria-hidden="true">#</a> 数值关系运算</h3><p>常用的数值关系运算表达式有 (此处省略了 <code>[[ ]]</code>)</p><ul><li><code>${a} -eq ${b}</code> 检测两个数是否相等</li><li><code>${a} -ne ${b}</code> 检测两个数是否不相等</li><li><code>${a} -gt ${b}</code> 检测变量 <code>a</code> 是否大于 <code>b</code></li><li><code>${a} -lt ${b}</code> 检测变量 <code>a</code> 是否小于 <code>b</code></li><li><code>${a} -ge ${b}</code> 检测变量 <code>a</code> 是否大于等于 <code>b</code></li><li><code>${a} -le ${b}</code> 检测变量 <code>a</code> 是否小于等于 <code>b</code></li></ul><h3 id="字符串关系运算" tabindex="-1"><a class="header-anchor" href="#字符串关系运算" aria-hidden="true">#</a> 字符串关系运算</h3><p>常用的字符串关系运算表达式有</p><ul><li><code>${str1} = ${str2}</code> 检测两个字符串是否相等 (注意只有一个等号)</li><li><code>${str1} != ${str2}</code> 检测两个字符串是否不同</li><li><code>-z ${str}</code> 检测字符串是否为空 (长度为 0)</li><li><code>-n ${str}</code> 检测字符串是否不为空 (长度不为 0)</li><li><code>${str}</code> 检测是否有字符串, 即任意字符串的表达式结果均为真, 不存在 false, 0 等表述</li></ul><h3 id="文件关系运算" tabindex="-1"><a class="header-anchor" href="#文件关系运算" aria-hidden="true">#</a> 文件关系运算</h3><p>常用的文件关系运算表达式有 (注意, 以文件的路径字符串表示被检测的文件)</p><ul><li><code>-f/d/c/L ${path}</code> 检测该路径是否指向一般文件, 目录, 设备, 连接</li><li><code>-r/w/x ${path}</code> 检测脚本对该文见是否有读取, 写入, 执行权限</li></ul><h2 id="流程控制" tabindex="-1"><a class="header-anchor" href="#流程控制" aria-hidden="true">#</a> 流程控制</h2><p>注意, 使用流程控制语句时, 换行方式最好与基本格式保持一致<br> 如果在终端中, 则可使用 <code>;</code> 代替换行</p><h3 id="if-语句" tabindex="-1"><a class="header-anchor" href="#if-语句" aria-hidden="true">#</a> if 语句</h3><p>if 语句格式如下</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">if</span> 条件1\n<span class="token keyword">then</span>\n满足条件时执行 <span class="token punctuation">..</span>.\n<span class="token keyword">elif</span> 条件2\n<span class="token keyword">then</span>\n满足条件时执行 <span class="token punctuation">..</span>.\n<span class="token keyword">else</span>\n否则执行 <span class="token punctuation">..</span>.\n<span class="token keyword">fi</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 if 时注意</p><ul><li>允许有多个 <code>elif</code> 分支, 且 <code>elif</code> 与 <code>else</code> 不是必须的</li><li>if 中不允许有空的分支</li><li>if 语句的条件本质为执行命令, 并根据命令是否执行成功判断 (<code>$?=0</code>), 因此可使用<a href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97">关系运算</a>作为条件</li></ul><h3 id="case-语句" tabindex="-1"><a class="header-anchor" href="#case-语句" aria-hidden="true">#</a> case 语句</h3><p>case 语句格式如下</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">case</span> 判断值 <span class="token keyword">in</span>\n情况1<span class="token punctuation">)</span>\n    满足情况执行 <span class="token punctuation">..</span>.\n    <span class="token punctuation">;</span><span class="token punctuation">;</span>\n情况2<span class="token punctuation">)</span>\n    满足情况执行 <span class="token punctuation">..</span>.\n    <span class="token punctuation">;</span><span class="token punctuation">;</span>\n<span class="token keyword">esac</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 case 注意</p><ul><li>当判断值为数字时, 一般直接读取变量 <code>${a}</code> 即可</li><li>当判断值为字符串变量 <code>str</code> 时, 判断值需要表示为 <code>&quot;${str}&quot;</code></li><li>使用 <code>|</code> 可以并列表示多个情况</li><li>对于其他情况, 可使用 <code>*</code> 代替</li></ul><h3 id="for-循环" tabindex="-1"><a class="header-anchor" href="#for-循环" aria-hidden="true">#</a> for 循环</h3><p>指定循环次数时, for 循环的格式为 (注意空格)</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> <span class="token operator">&lt;</span>定义<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token operator">&lt;</span>边界<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token operator">&lt;</span>步长<span class="token operator">&gt;</span> <span class="token punctuation">))</span></span>\n<span class="token keyword">do</span>\n循环执行的语句 <span class="token punctuation">..</span>.\n<span class="token keyword">done</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用这种语法的 for 循环注意</p><ul><li>其中的定义, 边界, 步长与 C 语言类似, 且定义时不需要知名类型<br> 例如 <code>(( i = 0; i &lt; 10; i++ ))</code>, 则将进行十次循环 (<code>+=</code> 运算也支持)</li><li>该语法仅在部分 Shell 中支持, 如 zsh 与 bash, 但对于 ubuntu 的默认 Shell 程序 dash 不支持</li><li>迭代变量可通过 <code>${迭代变量名}</code> 访问</li></ul><p>除了指定循环次数, for 循环还可用于遍历数组, 基本格式为</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">for</span> <span class="token operator">&lt;</span>迭代变量名<span class="token operator">&gt;</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>迭代序列<span class="token operator">&gt;</span>\n<span class="token keyword">do</span>\n循环内容 <span class="token punctuation">..</span>.\n<span class="token keyword">done</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用时注意</p><ul><li>最简单的可通过 <code>元素1 元素2 ...</code> 表示迭代序列, 将按空格划分元素</li><li>如果给出一个字符串, 则也将一类似的方式解析, 即按空格或换行划分字符串, 迭代各个子字符串 (该特性仅用于 bash, 在 zsh 中将视为一个整体)</li><li>如果希望迭代数组, 可通过<a href="#%E6%95%B0%E7%BB%84">数组信息</a>, 使用 <code>${arr[*]}</code> 迭代数组元素, 或 <code>${!arr[*]}</code> 迭代数组索引</li><li>此外, 还可以使用命令 <code>seq &lt;序列长度&gt;</code> 生成指定长度的序列, 如 <code>$(seq ${n})</code> 将生成一个 1 - n 的序列, 完成 <code>n</code> 次循环, 实现类似指定次数循环的效果</li></ul><h3 id="while-循环" tabindex="-1"><a class="header-anchor" href="#while-循环" aria-hidden="true">#</a> while 循环</h3><p>while 循环有基本结构</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">while</span> 条件\n<span class="token keyword">do</span>\n循环内容 <span class="token punctuation">..</span>.\n<span class="token keyword">done</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用时注意</p><ul><li>while 循环的条件与 <a href="#if-%E8%AF%AD%E5%8F%A5">if 语句</a>相同</li><li>当条件为字符串 <code>true</code> 时, 为无限循环, 此时可通过 <kbd>Ctrl</kbd>+<kbd>D</kbd> 强制退出脚本</li><li>将 while 改为 until, 则变为 do-until 循环</li></ul><h3 id="循环控制" tabindex="-1"><a class="header-anchor" href="#循环控制" aria-hidden="true">#</a> 循环控制</h3><p>对于 for 与 while 循环, 有如下循环控制语句</p><ul><li><code>break</code> 退出循环</li><li><code>continue</code> 退出当此循环</li></ul><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h3><p>使用如下方式即可定义函数, 其中关键字 <code>function</code> 不是必要的</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">function</span> <span class="token function-name function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    函数内容 <span class="token punctuation">..</span>.\n    <span class="token builtin class-name">return</span> 返回值<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用函数时注意</p><ul><li>使用调用命令的方式调用函数, 如 <code>&lt;函数名&gt; [参数1] [参数2] ...</code></li><li>函数中同样使用 <code>${n}</code>, <code>$#</code> 等<a href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">特殊变量</a>接收参数以及参数数量, 而不需要而外定义</li><li>函数执行后, 返回值将赋给特殊变量 <code>$?</code></li><li>函数的返回值只能是 0-255 的整数, 且一般执行成功时返回 0, 也可以不设置返回值, 此时返回最后一条命令的状态</li><li>当函数的返回值为 <code>0</code> (表示 true) 或非 <code>0</code> 值时, 可将函数用于 <a href="#if-%E8%AF%AD%E5%8F%A5">if 语句</a>的条件中</li><li>如果希望从函数中获取复杂信息, 则可使用 <code>$(命令)</code> 的方式调用函数, 接收函数通过 <code>echo</code> 输出的内容</li><li>可通过 <code>source</code> 指令<a href="#%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">执行其他脚本</a>的方式, 引入其他脚本中的函数</li><li>函数中定义的变量默认为全局有效, 如果希望定义局部变量, 需要在变量定义前加上关键字 <code>local</code></li></ul><h2 id="高级使用技巧" tabindex="-1"><a class="header-anchor" href="#高级使用技巧" aria-hidden="true">#</a> 高级使用技巧</h2><h3 id="重定向" tabindex="-1"><a class="header-anchor" href="#重定向" aria-hidden="true">#</a> 重定向</h3><p>关于重定向的更多内容, 详见有关教程的介绍, 此处仅介绍基本使用</p><p>Linux 程序通过标准输入 <code>stdin</code> 读取信息, 并将信息输出到标准输入 <code>stdout</code> 中, 其中错误则输出到标准错误 <code>stderr</code> 中<br> 一般情况下标准输入, 标准输出, 标准错误均为终端, 且这三者在 Linux 都被视为文件, 分别有文件描述符 (类似文件句柄) <code>0, 1, 2</code>, 文件本体则位于目录 <code>/dev</code> 下</p><p>通过将 <code>stdout</code> 重定向为指定文件, 可实现将命令的输出保存到指定文件中</p><ul><li><code>command &gt; file</code> 将命令的标准输出重定向为文件 <code>file</code> (可用变量, 字符串表示), 此时输出将覆盖文件 <code>file</code> 内原有的内容</li><li><code>command &gt;&gt; file</code> 将命令的标准输出重定向为文件 <code>file</code>, 此时输出将在 <code>file</code> 原有内容的基础上追加</li></ul>',71),z=e("code",null,"stdin",-1),D=e("br",null,null,-1),T=o('<ul><li><code>command &lt; file</code> 将标准输入重定向为已有文件 <code>file</code></li><li><code>command &lt;&lt; TAG ... TAG</code> 将标准输入重定向为使用 <code>TAG</code> 包裹的多行内容 (<code>TAG</code> 可以替换为任意英文组合), 可使用此方法在终端中输入多行内容 (<mark>注意这不是命令的参数</mark>)</li></ul><p>使用时注意</p><ul><li><code>command</code> 为<mark>包括参数的完整命令</mark></li><li>重定向输出时, 文件 <code>file</code> 不存在时将自动创建; 重定向输入时, 文件 <code>file</code> 必须存在</li><li>对于 <code>stderr</code> 的重定向, 则使用 <code>2&gt;</code> 与 <code>2&gt;&gt;</code> 代替</li><li>对于同一命令可设置多个重定向, 如 <code>command &lt; infile &gt; outfile 2&gt; errfile</code> 将标准输入重定向为文件 <code>infile</code>, 标准输出重定向为文件 <code>outfile</code>, 标准错误重定向为文件 <code>errfile</code></li><li>系统中有特殊文件 <code>/dev/null</code>, 该文件无法读取到任何内容, 且任何输入内容都会被丢弃, 因此可将标准输出重定向到该文件中, 以实现不显示命令输出的效果</li></ul><h3 id="管道" tabindex="-1"><a class="header-anchor" href="#管道" aria-hidden="true">#</a> 管道</h3><p>重定向使命令能与文件之间进行交互, 如果希望多个命令之间进行交互, 则可使用管道符</p><p>管道的基本格式为 <code>命令1 | 命令2 | 命令3 ...</code></p>',6),G=e("li",null,"管道连接的各个命令将从做向右执行, 且上一个命令的标准输出都将重定向为下一个命令的标准输入",-1),N=e("li",null,[l("管道的命令无法从终端获输入, 但可通过"),e("a",{href:"#%E9%87%8D%E5%AE%9A%E5%90%91"},"重定向"),l("为第一个命令提供输入以及重定向最后一个命令的输出")],-1),V=e("code",null,"ls | grep test",-1),I=e("code",null,"test",-1),R=o('<h3 id="参数传递过滤器" tabindex="-1"><a class="header-anchor" href="#参数传递过滤器" aria-hidden="true">#</a> 参数传递过滤器</h3><p>注意, 无论时重定向还是管道, 都只能设置标准输入, 而无法设置命令的参数<br> 如果希望将标准输入转化为命令参数, 则可以使用命令 <code>xargs</code></p><p>使用 <code>xargs</code> 时, 首先将从标准输入接收信息, 然后解析接收到的信息</p><ol><li>按指定规则将信息分割为多个命令参数</li><li>按指定规则, 将这些参数分组</li><li>将每组划分的参数与给出的命令拼接得到完整命令, 并执行各组命令</li></ol><p>命令的基本格式如下</p><p><code>xargs [-d&lt;ch&gt; | -0] [-n&lt;x&gt;] [-r] [-p] [-e&lt;ch&gt;] &lt;command&gt;</code></p><ul><li><code>-d&lt;ch&gt;</code> 设置参数间的分界符为 <code>ch</code>, 默认为空格</li><li><code>-0</code> 设置参数间的分界符为 <code>\\0</code> (推荐将分界符设置为 <code>\\0</code>, 以防止误将参数识别为分界符)</li><li><code>-n&lt;x&gt;</code> 以 <code>x</code> 个参数为一组执行命令, 默认为按换行划分</li><li><code>-r</code> 如果从标准输入没有接收到信息, 则停止执行命令</li><li><code>-p</code> 在执行各组命令前进行询问</li><li><code>-e&lt;ch&gt;</code> 当接收到字符 <code>ch</code> 时, 停止接收数据的处理</li><li><code>command</code> 待拼接的命令 (该命令也可以带参数, 拼接的参数将跟在后面)</li></ul>',7),H=e("code",null,"ls -l",-1),P=e("br",null,null,-1),W=e("code",null,"find ... -print0 | xargs -0 ls -l",-1),j=e("code",null,"-print0",-1),J=e("code",null,"-0",-1),K=e("code",null,"\\0",-1),M=e("h3",{id:"启动时执行",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#启动时执行","aria-hidden":"true"},"#"),l(" 启动时执行")],-1),O=e("br",null,null,-1),Q=o("<p>一般情况下</p><ul><li>针对所有 Shell 脚本, 启动时都将调用脚本 <code>/etc/profile</code> (全局) 与 <code>~/.profile</code> (用户)</li><li>针对特定脚本程序, 这些文件一般具有名称 <code>&lt;Shell 程序名&gt; + rc</code> (不固定) <ul><li>位于文件夹 <code>/etc/</code> 下时, 任何用户的 Shell 启动时都会运行该脚本</li><li>位于文件夹 <code>~/</code> 下时, 该用户的 Shell 启动时将运行该脚本</li></ul></li></ul><p>注意, 编写启动时执行的脚本时, 应当使用绝对路径</p>",3);function U(X,Y){const n=i("ExternalLinkIcon"),c=i("RouterLink");return t(),r("div",null,[u,e("p",null,[l("参考教程 "),e("a",p,[l("https://www.runoob.com/linux/linux-tutorial.html"),d(n)])]),b,e("ul",null,[f,e("li",null,[l("将脚本视为可执行程序运行 "),m,k,l(" 使用该方法时, 脚本文件需要有"),d(c,{to:"/coding/web/linux/base.html#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"},{default:a(()=>[l("执行权限")]),_:1})]),_]),v,g,e("p",null,[l("除了如 "),x,l(" 等程序控制关键字以及定义的子命令 (函数), 每个语句都相当与执行一个程序 (对于命令实际对应的程序可通过指令 "),d(c,{to:"/coding/web/linux/base.html#%E5%85%B6%E4%BB%96%E5%AE%9E%E7%94%A8%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4"},{default:a(()=>[l("whereis")]),_:1}),l(" 查询), 且都是 "),$,l(" 的格式, 一般也将这些语句称为命令"),E,l(" 因此可通过 bash 脚本组织一系列命令的执行, 减少重复输入命令")]),w,e("ul",null,[A,B,S,y,e("li",null,[l("此外还有一些特殊变量 "),e("ul",null,[e("li",null,[F,l(" 表示当前脚本路径 (不包含参数与 Shell 程序), 可配合 "),d(c,{to:"/coding/web/linux/base.html#%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2"},{default:a(()=>[l("dirname")]),_:1}),l(" 获取脚本所在目录")]),q])]),C]),L,e("p",null,[l("通过将 "),z,l(" 重定向为指定文件, 可实现以已有的文件内容代替用户输入"),D,l(" 配合 "),d(c,{to:"/coding/web/linux/base.html#%E5%86%85%E5%AE%B9%E6%90%9C%E7%B4%A2"},{default:a(()=>[l("grep")]),_:1}),l(" 等命令对结果内容进一步筛选")]),T,e("ul",null,[G,N,e("li",null,[l("管道可以配合 "),d(c,{to:"/coding/web/linux/base.html#%E5%86%85%E5%AE%B9%E6%90%9C%E7%B4%A2"},{default:a(()=>[l("grep")]),_:1}),l(" 等命令对结果内容进一步筛选, 实现查询命令结果的效果, 如 "),V,l(" 将列出所有名称带有 "),I,l(" 的文件")])]),R,e("p",null,[l("例如"),d(c,{to:"/coding/web/linux/base.html#%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"},{default:a(()=>[l("查找文件")]),_:1}),l("时, 可使用此方法将查找结果分组作为 "),H,l(" 的参数, 实现显示查找结果信息的效果, 如"),P,W,l(" (该例子通过 "),j,l(" 与 "),J,l(" 选项, 约定了以 "),K,l(" 为参数分界符, 防止误将文件名识别为分界符)")]),M,e("p",null,[l("在 Shell 启动时 (不是系统启动, 系统启动执行参见"),d(c,{to:"/coding/web/linux/base.html#%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"},{default:a(()=>[l("定期执行任务")]),_:1}),l("), 将会执行一段特殊的 Shell 脚本"),O,l(" 可以在此脚本中完成设置环境变量, 定义函数等操作")]),Q])}const le=s(h,[["render",U],["__file","shell.html.vue"]]);export{le as default};
