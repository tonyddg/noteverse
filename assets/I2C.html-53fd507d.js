import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as e,e as a}from"./app-8c5ce49e.js";const s={},r=a('<h1 id="通信协议-i2c" tabindex="-1"><a class="header-anchor" href="#通信协议-i2c" aria-hidden="true">#</a> 通信协议 I<sup>2</sup>C</h1><h2 id="外设介绍" tabindex="-1"><a class="header-anchor" href="#外设介绍" aria-hidden="true">#</a> 外设介绍</h2><h3 id="物理层" tabindex="-1"><a class="header-anchor" href="#物理层" aria-hidden="true">#</a> 物理层</h3><ol><li>使用两条总线与多个设备连接(通信从机)</li><li>SDA 双向串行数据线</li><li>SCL 串行时间线 同步数据收发</li><li>每个连接的设备都有一个独立地址, 通过地址访问</li><li>总线通过上拉电阻连接电源, 设备空闲时输出高阻态, 所有设备输出高阻态时, 总线变为高电平</li></ol><h3 id="协议层" tabindex="-1"><a class="header-anchor" href="#协议层" aria-hidden="true">#</a> 协议层</h3><ol><li>主机广播传输起始信号</li><li>主机广播从机地址信号, 与设备地址相同时, 选中设备, 其他设备将忽略之后的信号</li><li>从机/从机发出应答/非应答信号, 只有收到应答信号, 主机才能继续收发数据</li><li>I2C 中采用 MSB first(most significant bit), 即先传输二进制数据的最高位</li></ol><ul><li>写数据 主机向从机发送 8 位的数据包, 然后等待从机应答信号, 不断重复, 直到主机发送停止传输信号</li><li>读数据 从机向主机发送 8 位的数据包, 然后等待主机的应答信号, 不断重复, 直到主机发送非应答信号</li><li>读写过程 通过重复读写信号 + 从机地址, 实现对从机的多次读写</li></ul><h3 id="传输信号" tabindex="-1"><a class="header-anchor" href="#传输信号" aria-hidden="true">#</a> 传输信号</h3><ol><li>起始信号(S) SCL 为高电平, SDA 从高电平切换至低电平</li><li>停止信号(P) SCL 为高电平, SDA 从低电平切换至高电平</li><li>数据的有效性 SCL 为高电平时, SDA 的数据为有效数据, SCL 为低电平时, SDA 切换电平</li><li>设备地址 可以是 7 位 或 10 位, 一般为 7 位</li><li>数据方向 在设备地址后指定, 1 表示主机向从机读数据, 0 表示主机向从机写数据</li><li>应答(ACK/NACK) 发送完 8 位数据后, 接收端输出应答信号, SDA 位高电平, 表示非应答(NACK), 低电平表示应答(ACK)</li></ol><h3 id="i2c-特性" tabindex="-1"><a class="header-anchor" href="#i2c-特性" aria-hidden="true">#</a> I<sup>2</sup>C 特性</h3><p>可以通过程序模拟 I<sup>2</sup>C 协议, 实现软件模拟协议, 也可通过STM32 的 I<sup>2</sup>C 外设, 实现硬件协议 通过查询手册得到STM32 上的 I<sup>2</sup>C 通信引脚</p><h3 id="stm32-i2c-通信过程" tabindex="-1"><a class="header-anchor" href="#stm32-i2c-通信过程" aria-hidden="true">#</a> STM32 I<sup>2</sup>C 通信过程</h3><ul><li><p>主发送器</p><ol><li>控制器发出起始信号(S), 产生事件 EV5(起始信号已发送)</li><li>发送设备地址并等待应答, 当从机应答, 产生事件 EV6(数据已发送) 及 EV8(数据寄存器为空)</li><li>清零 ADDR(清除 EV6)</li><li>向数据寄存器(DR)写入数据, EV8 事件结束, 发送数据后, 再次产生 EV8 事件, 不断重复</li><li>设置 CR1 寄存器的 STOP 位, 结束发送, 发送完最后一个数据将产生 EV8_2 事件, 然后发出停止信号(P)</li></ol><ul><li>通过启动 I<sup>2</sup>C 中断, 进入中断函数, 判断事件, 实现信号发送</li></ul></li><li><p>主接收器</p><ol><li>1, 2 步同发送器</li><li>当主机接收到数据后, 产生事件 EV7(数据寄存器非空/接收到数据), 读取数据后, 事件结束</li><li>读取数据后可以发送 应答/非应答 信号, 若应答则重复接收, 否则停止接收, 接收到的最后一个数据将产生 EV7_1 事件, 并发出停止信号</li></ol></li></ul><h2 id="标准库配置" tabindex="-1"><a class="header-anchor" href="#标准库配置" aria-hidden="true">#</a> 标准库配置</h2><h3 id="i2c-初始化结构体" tabindex="-1"><a class="header-anchor" href="#i2c-初始化结构体" aria-hidden="true">#</a> I<sup>2</sup>C 初始化结构体</h3><ol><li>I2C_ClockSpeed 配置 I<sup>2</sup>C 传输速率, 参数值不得高于 400kHz</li><li>I2C_Mode 选择 I<sup>2</sup>C 的模式, I2C 与 SMBusHost/Device, 使用 I2C 不需要区分主从</li><li>I2C_DutyCycle 设置 SCL 线时钟占空比, 2 表示 2:1; 16_9 表示 16:9, 两个模式差别不大</li><li>I2C_OwnAddress1 STM32 设备自己的地址, 7 位或 10 位(与设置有关), 只要唯一即可</li><li>I2C_OwnAddress2 STM32 设备自己的第二个地址, 只允许 7 位</li><li>I2C_Ack_Enable I<sup>2</sup>C 答应设置, 一般设置为 Enable</li><li>I2C_AcknowledgeAddress 设置地址的长度, 7 位或 10 位</li></ol>',16),d=[r];function h(c,n){return l(),e("div",null,d)}const u=i(s,[["render",h],["__file","I2C.html.vue"]]);export{u as default};
