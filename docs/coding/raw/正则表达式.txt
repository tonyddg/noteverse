正则表达式

0./正则表达式的开始与结束
1.定位符
^	字符串的开始
$	字符串的结尾
\b	单词与空格的位置
(在开始表示单词的第一个字母，在最后表示单词的最后个字母)
/\bCha/ 以Cha开头的单词 /ter\b/ 以ter结尾的单词
\B	单词中的任意位置，不包括边界
/\BCha/ 不匹配Chapter

2.字符或字集出现次数限制
+	一次或多次(尽可能多的匹配)
*	零次或多次(可能出现空格问题)
?	一次或零次
{n}	出现n次
{n,}	出现至少n次
{n, m}	出现n到m次
3.字集[]
A.范围限定-
使用a-z表示a到z的所有字符
两个范围之间不用分隔号
B.取反字集^
在字集符的开头，为字集排除设定字符
C.转义字符 基本同C++
表达预设的字符也要使用\[预设的字符]
\cx代表Contorl+x
D.预设字集
\w	字母数字下划线 等价于 [a-zA-Z0-9_]
\W	非字母数字下划线
\s	任何空白的字符 等价于 [ \f\n\r\t\v]
\S	任何非空白字符 等价于 [^ \f\n\r\t\v]
.	除换行符 \n 之外的任何单字符
E.选择字集 ()
([选择器])将会把()内的内容选中
对于有选择字集的正则表达式，使用match后，将返回一个数组
索引0对应被匹配的字符串，之后的索引代表各个被选择的部分
一个括号表示一个索引，如果没匹配到则为undefined
使用\[正整数n]表示第n个被选择的字符(串) /([a-z]+)\1/ 将匹配123123
可以将选择字符集作为一个字集使用/1(,000)+/ 将匹配1,000,000
在(replace)替换中，可用$n指代被提取的字符串
注意*+在括号内会将所有部分提取，否则只提取一段
(a+) 与 (a)+匹配aaa
第一个的$1为aaa，第二个的$1为a

F.选择字集的前缀(此时均不缓存选择字符集)
?:	不缓存选择字符集
?=	将选择字符集特化为后方定位符，获取结果时不返回
/[a-z]+(?=[0-9]+)/ 将数字的开始作为末尾，匹配后面连着数字的字母
匹配abc123efg，返回abc
?<=		将选择字符集特化为前方定位符，获取结果时不返回
?!		匹配的内容为非选择字符集内的内容，其他同
?<!		匹配的内容为非选择字符集内的内容，其他同
?<[字符串]>	用于php，将得到的子字集命名

4.修饰符
接在末尾的/后
g	全局匹配，将会匹配所有符合的字符串，不是只匹配第一个
(match的获取()内容的功能在开启g时失效)
i	不区分大小写
m	多行模式，此时^(开始定位)与$(结束定位)会匹配/n

5.特殊：|
(表达式1)|(表达式2) 两个表达式其中一个符合即可
注意，表达式为从左到右比较，到第一个符合的停下
因此字符多的，难匹配的应优先在前
eg (\|~|&~|[\|&~])优先匹配符号组合

6.在javascript中的使用
使用时不需要加引号
String.match([正则表达式])		返回匹配的正则表达式
String.replace([正则表达式], [str])	用str替换匹配的位置，不直接替换，返回修改后的字符串	
[正则表达式].test([str])		检测str是否符合正则表达式			

7.在php中使用
php中正则表达式需要使用引号，且没有修饰符g(使用preg_match_all)
preg_match([正则表达式字符串], [被检查的字符串], [用于接收结果的变量], [flag], [开始检索位置])
preg_match_all([正则表达式字符串], [被检查的字符串], [用于接收结果的变量], [flag], [开始检索位置])
！注意preg_match(_all)的结果保存在一个用于接收结果的变量中，需要在函数的参数中指明，返回值为匹配的个数
接收到的结果为Array[所有匹配的字符串或选择字符串][第n个匹配的字符串]
如果对选择的子字符命名，则可用索引数组的方式访问Array[名称][第n个匹配的字符串]
即使命名过，依然会再使用数值保存一次
preg_replace([正则表达式], [替换字符串], [替换目标], [替换次数], [接收替换次数])
preg_replace_callback([正则表达式], 替换函数, [替换目标], [替换次数], [接收替换次数])
替换函数接受一个数组matches，matches[n]为第n个被选择的字符串，从1开始

实例
解析url
/(\w+):\/\/([^\/:]+):?(\d*)?([^#? ]*)([?#])?([^ ]*)/
1.获取协议 2.获取域名 3.获取端口 4.获取地址 5.获取参数的类型(#或?) 6.获取参数
2.域名以/(地址开始)或:(端口开始)为结束标识
因此可以设置[^/:]+，表示直到/或:结束
3.由于端口可能省略，且端口固定为:+数字的形式，因此?更好
4.地址可能省略，地址形式不确定，但以#为结尾，因此需要*
5.获取端口时为了只获取到数字使用 :? 

删除第一个AND或OR
    //"/([^\s]+)\s/"将字符串按空格拆分
    $res = preg_replace_callback("/([^\s]+)\s/", function($matches)
    {
        if($matches[1] == "AND" || $matches[1] == "OR")
        {
            return "";
        }
        else 
        {
            return $matches[1] . ' ';
        }
//只替换1次，实现只替换第一个的效果
    }, $res, 1);

注意
/\s(\w+)\s/，每次识别字符串为" abc "，包括两侧的空格
"abc cde efg" 只有 cde 匹配