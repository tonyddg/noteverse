访问mysql
mysql -u [用户名] -p[密码，无空格]

mysql的命令提示符
MariaDB [被操作的数据库]>	等待输入命令
->	等待输入命令的下一行
' " `>	等待输入对应符号中的内容
\*>	等待输入注释的内容
使用\c取消已输入的命令

数据库命令都要以 ; 否则将在下一行继续补充输入

查看所有的数据库/表
SHOW databases/tables;
创建数据库 CREATA DATABASE [数据库名];
使用数据库 USE [数据库名]; 操作数曲库前必须使用
创建用户
GRANT [权限] ON [数据库 *为全部].[数据库的表 *为全部] TO '[用户名]'@'[地址]' IDENTIFIED BY '[密码]';
一般全部权限为 ALL 使用 REVOKE 移除权限、
创建表 CREATE TABLE [表名]([列1] [列1类型](长度) [列属性], ....) ENGINE [使用的储存引擎 一般为InnoDB];
删除表 DROP TABLE [表名];

当数据超出大小时将会被截断
类型		最大长度	特性
CHAR		255	一般字符，多余位置将补空格，效率高
VARCHAR	65536	可变长度，效率低
BINARY		255	存储二进制数据，多余位置将补空格，效率高
VARBINARY	65536	存储二进制数据，可变长度，效率低

TINYTEXT		255	无默认值，只能对前几个字符引索，其他同VARCHAR
MEDIUMTEXT	65536	...
TEXT		1E+7	...
LONGTEXT	4E+9	...

...BLOB		...	二进制数据，无默认值，同TEXT有4种规格

数值类型
整形 INT 有4种类型(TINY(1) SMALL(2) MEDIUM(3) /(4) BIG(8)) 无符号时要有属性 UNSIGNED
浮点型 FLOAT(4) DOUBLE(8) 必有符号

创建表时，数值类型后的()中的参数指检索后的显示宽度，使用属性 ZEROFILL来使显示补零

时间类型
TIME 		仅时间
DATE 		仅日期
TIMESTAMP 	unix时间戳
DATETIME 	任何日期('YYYY-MM-DD HH:MM:SS' 格式的字符串)

常用属性
NOT NULL 		不可设为null
AUTO_INCREMENT		为每一行设定唯一的值
KEY			改列适合作为引索
UNSIGNED		无符号类型

查看表的列信息 DESCRIBE [当前数据库中的表];

修改表的信息 ALTER TABLE [选择的表] ADD(添加)/DROP(删除) [列名称 (创建属性)];
重命名表 ALTER TABLE [选择的表] RENAME [新名字];
重命名列 ALTER TABLE [选择的表] CHANGE [选择的列] [新名字] (列的原类型);
修改列的数据类型 ALTER TABLE [选择的表] MODIFY [列名] (新数据类型)
如果能合理转换将进行自动转换

添加索引 ALTER TABLE [选择的表] ADD INDEX([列名](限制索引的字符));
添加索引(无法添加PRAMARY KEY) CREATE INDEX [列名] ON [选择的表] ([列名](限制索引的字符));
在创捷列表是在后补充参数 INDEX([列名](限制索引的字符/数值则不需要)) 也可在创建表的时候建立索引
CREATE TABLE test(author VARCHAR(128), INDEX(author(20)));

主键
设为主键时须向列添加 PRIMARY KEY
作为主键时，各行的值不可以相同，且只能有一个主键
添加主键 ALTER TABLE [选择的表] ADD PRIMARY KEY([作为主键的列]);
添加或设置为主键时要保证该列的各行值均不相同

FULLTEXT 全文索引
将字符串解析为一篇文章，对其中的各个单词进行索引
仅可对VARCHAR CHAR TEXT使用
建立全文索引 ALTER TABLE [选择的表] ADD FULLTEXT(使用全文索引的列);
可以为多个列设置全文索引
全文索引中不区分大小写，且有500个排除单词集(介词，连词等)，在集中的单词不会被录入

修改行的信息
UPDATE [查询的表] SET [修改表达式] (限定符);
如果限定符同时指向多行，将同时修改
删除行
DELETE FROM [查询的表] (限定符);
向表中添加数据 INSERT INTO [表名](表中的列) VALUES(各个列对应的值), (第二行的值的信息),...;
若没有指明(表中的列)对应的值则以DESCRIBE中的顺序插入

查询数据库
SELECT [显示的列] FROM [查询的表] (限定符);
使用 * 表示通配 可用 , 指定多个列

统计行数 SELECT COUNT(*) FROM [查询的表] (限定符);
关于COUNT的补充 https://www.cnblogs.com/-flq/p/10302965.html
不重复显示,如果两行内容相同不重复显示 SELECT DISTINCT [显示的列] FROM [查询的表] (限定符);
删除行 DELECT FROM [查询的表] (限定符); 

限定符
WHERE 返回使后方表达式成立的值
1.使用 = 表达式
SELECT cola, colb FROM table WHERE cola = "abc";
找出table里所有cola = "abc"的行，显示其cola与colb的值
2.使用 LIKE 表达式
同 = ，但可以在字符串内使用 %通配符，表示任意个数的任意字符
WHERE cola LIKE "abc%"; 只要当改行cola的开头为abc就匹配

LIMIT 限定查询的行数
LIMIT a; 返回a行结果
LIMIT a, b; 返回第a行之后的b行结果,偏移从0开始

WHERE MATCH ... AGAINST 自然语言查询(用于FULLTEXT);
WHERE MATCH(查询的列) AGAINST("查询的字符串 需要加引号");
当查询一个排除单词集中的单词时，只会返回空(被排除)
几个查询的单词以空格分隔，必须同时出现才会作为结果
布尔模式
AGAINST("查询的字符串 需要加引号" IN BOOLEAN MODE);
此时查询的单词只要至少一个出现即可
前缀 - 为排除这个单词 + 为必须有这个单词
当所查询的为词组时，则需要在外部使用单引号内部使用双引号将词组包括，其他同

ORDER BY 
限定返回结果的排序依据
ORDER BY [依据的列] (升序 ASC/降序 DESC), ....(第二依据), ...;

GROUP BY
将返回结果分组，通常配合COUNT()
SELECT cola, COUNT(*) FROM table GROUP BY cola;
将统计cola的各个值重复出现过的次数(如图书库中每个作者的作品数)

联结选择
SELECT [显示的列] FROM [多个被联结的表] WHERE (联结表达式);
使用 [表].[列] 表示某个表的某一列 表达式可用 a.cola = b.colb;
等效的语句
SELECT [显示的列] FROM [被联结的表a] NATURAL JOIN [被联结的表b]; 自动联结同名列
SELECT [显示的列] FROM [被联结的表a] JOIN [被联结的表b] ON (联结表达式);

逻辑运算符
对于WHERE中的表达式(= 与 LIKE)可以进一步使用AND OR NOT来使用多个表达式
WHERE cola LIKE "abc" OR colb LIKE "%cdf";

注意！！比较时
NULL与任何其他数据比较，均返回false

MYSQL内置函数 操作字符串，日期等
https://www.runoob.com/mysql/mysql-functions.html

数据库规范化

首要要求：确保每一行都有唯一主键 可使用AUTO_INCREMENT 或其他标识符
预先步骤：思考数据库将储存的数据并制作出雏形
规范化
第一范式：
1.没有包含同种数据的重复列 2.所有列都只能包含一个值
eg
1.保存地址时不能只用一个简单的字符串，而应该使用国家，省，市，县....多个列(此情况只需拆分列)
2.保存一本书的作者时，一本书可能写了多个作者，多个列等价，此时需要以下方法
对不符合第一范式的列可以在主表中移除这些列使用增加表来优化
优化为：
主要表：主键->优化后的行
由于列包含多个值，表明一个主键可以对应多个值(此时一个值也可能对应多个主键)，建立辅助表，再与主表联结将提高查询效率
辅助表：(主键<->重复列)(值对)
优点：减少多余的列数，减少每一列元素的大小，使表更清晰，增加查询效率

第二范式：
列的不同的行之间不能有重复数据
eg
1.记录客户信息时，一个客户可能进行多次购买，购买记录中的顾客信息将重复
对不符合第二范式的列可以在主表中移除这些列使用增加表来优化
优化为：
主要表：主键->优化后的行
列的不同的行之间有重复数据时，可以采用简单的编号来指代这些数据，再使用一个表来映射这些编号
优点：减少重复的数据

第三范式：(仅重要的列必要)
通过拆分各个列，使所有表严格服从具有唯一明显主键的关系
eg 
计入地址信息时使用 只需知道邮编就可以查询到其他信息 且修改成本低
A(唯一主键)邮编->城市 B(唯一主键)城市->市 C(唯一主键)市->省

总结：
一对一关系 理想的状态

一对多关系 应将多的一侧作为主键 通过编号减少重复信息(重复信息多且复杂，否则无需中间表)
e.g. A(用户信息 <- 用户编号(主键)) B(用户编号 <- 订单信息)

多对多关系 通过建立一个中间表实现 A-一对多->(中间编号表)B<-一对多-C
e.g. A(书本信息 <- ISBN) B(ISBN <-> 作者编号) C(作者编号 -> 作者)
通过书本信息->ISBN->作者编号->作者 
e.g. A(用户信息 <- 用户编号) B(用户编号 <-> ISBN) C(ISBN -> 书本信息)

一般经常使用的数据需要进行规范化，对于不重要的数据可以不使用规范化

事务：
在事务的过程中，操作都是临时的
开始事务 START TRANSACTION; 或 BEGIN;
提交操作 COMMIT;
撤销操作 ROLLBACK;

查看命令的运行状况
在命令前加上EXPLAIN 可以获取查询行时使用的键，方法等，用于检查查询效率

备份与还原

锁定数据库
LOCK TABLES [锁定的表1] READ,  [锁定的表2] READ, ...;
解锁数据库
UNLOCK TABLES [解锁的表1], [解锁的表2], ...;

备份
在外部使用命令 mysqldump -u [用户名] -p[密码，无空格] [备份的数据库] 进行备份
该命令会将备份内容输出到屏幕上，可使用转存符 > 将输出转存到文件中，一般命名为*.sql
使用 [数据库] [表] 备份其中的一张表
使用 --all-datebases 备份所有数据库
注意在备份时，要保证数据库无人修改，可以通过锁定数据库实现

恢复
mysql -u [用户名] -p[密码] < [备份的数据库地址]

输出为CSV格式
mysqldump -u [用户名] -p[密码，无空格] -tab=[保存地址，无引号] --fields-terminated-by=',' [输出的数据库]

