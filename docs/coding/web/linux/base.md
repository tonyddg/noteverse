# Linux 笔记
参考教程 <https://www.runoob.com/linux/linux-tutorial.html>

> todo : 迁移旧命令, p10k 显示用户

## 基本概念
### 路径
#### 路径的表示方式
* Linux 中, 使用 `/` 划分不同层级的目录
* Linux 中存在以下四种特殊目录用于目录开头
    * `/` 表示根目录 (用于绝对路径)
    * `./` 表示当前工作目录 (用于相对路径)
    * `~/` 表示用户的主目录
    * `..` 表示上一层目录
* 目录与文件的表示  
    * 通常以文件或目录的完整路径 (绝对或相对) 表示这一文件或目录  
    * 表示目录时, 可以在最后加上 `/` 以强调这是一个目录, 对于以目录为参数的命令无法识别目录时, 可尝试使用此方法

#### Linux 根目录结构
Linux 的根目录中, 一般有如下目录

* 一般文件目录
    * `/home` 存放各个用户的主目录, 一般主目录即 `/home/<用户名>`
    * `/root` root 用户的主目录
    * `/bin` 存放常用命令程序的二进制文件
    * `/sbin` 与 `/bin` 类似, 但存放的是管理员使用的命令程序
    * `/lib` 存放系统基本的共享库文件
    * `/usr` 共享资源目录, 一般软件就安装在这个目录下
        * `/usr/bin` 安装软件的二进制程序目录
        * `/usr/sbin` 管理员软件的二进制程序目录
    * `/etc` 存放系统或程序所需的配置文件
    * `/opt` 一般为空, 用于安装如数据库等软件
    * `/var` 一般用于存放程序日志文件的目录
    * `/tmp` 临时文件目录, 用于存放程序运行的临时文件
* 特殊文件目录
    * `/run` 记录程序运行时信息的目录, 每次重启时会被清空
    * `/lost+found` 一般为空, 当系统意外关机时将存放有关文件
    * `/boot` 系统启动时的核心文件目录
    * `/mnt` 其他文件系统的挂载目录, 例如 U 盘等将成为该目录下的一个特殊子目录 
* 设备文件目录 (该目录下的文件一般无法直接读取)
    * `/sys` 系统运行时的设备树
    * `/dev` 系统的外部设备以及虚拟设备 (如标准输入 `stdin`) 将被视为一个文件并存储在该目录中, 通过读写这些文件以访问设备
    * `/srv` 系统服务数据
    * `/proc` 系统内存的映射, 存储内核运行状态

### 命令与终端
#### 命令的基本格式
* 命令一般由执行命令的程序或命令头以及命令的参数组成
* 命令程序位于环境变量 `PATH` 中时, 直接使用程序名即可, 否则应指出具体路径, 注意相对路径的命令需要 `./`
* 单字母选项可使用 `-` 开头, 可多个选项字母并列于一个 `-` 后
* 多字母选项则使用 `--` 开头, 且一般独立出现
* 单字母的参数一般在 `-x` 后空一格写入参数内容
* 多字母的参数一般在 `--<x...>` 后使用 `=` 写入参数内容
* 对于由纯数字与字母的字符串可省略 `"`, 但除此之外的情况下, 最好加上 `"` (特别是含 `*` 的通配字符串)

#### 终端常用的快捷键
作用于单终端的环境
* <kbd>Ctrl</kbd> + <kbd>C</kbd> 向正在运行的程序发送信号 `SIGINT` 以终止程序的运行 (正常退出)
* <kbd>Ctrl</kbd> + <kbd>\\</kbd> 向正在运行的程序发送信号 `SIGQUIT` 以退出程序的运行 (错误退出)
* <kbd>Ctrl</kbd> + <kbd>D</kbd> 向正在接收标准输入的程序发送 `EOF`, 表示输入结束
* <kbd>Ctrl</kbd> + <kbd>Z</kbd> 暂停并挂起当前正在运行的程序, 将返回被挂起程序的序号
    * 使用命令 `bg <序号>` 在后台继续运行被挂起的程序
    * 使用命令 `fg <序号>` 在前台继续运行被挂起或移至后台运行的程序
    * 通过此方式可在单终端下在多个程序间切换
* <kbd>Ctrl</kbd> + <kbd>L</kbd> 清除屏幕上的内容 

作用于图形交互环境
* <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd> 复制选中内容 
* <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd> 粘贴选中内容 
* <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd> 打开新的终端

## 常用命令
### 文件管理
#### 基础文件管理
* `cp [-dpria] <src> <dest>` 复制文件或文件夹 (需要 `-r/a` 选项)
    * `src` 被复制文件的路径
    * `dest` 复制目标路径
    * `-d` 当被复制文件为软链接时, 则复制结果也为同一属性的软链接, 而不是复制原始文件
    * `-p` 同时复制[文件的属性](#文件属性), 而不是默认属性
    * `-r` 递归复制目录以及目录下的文件, 默认情况下只能复制文件与空文件夹, 如果要复制包含文件的文件夹, 需要使用此命令
    * `-i` 如果 `dest` 存在, 则进行覆盖查询, 否则将直接覆盖
    * `-a` 相当于 `-dpr`, 一般复制时会开启此选项
* `rm [-rfi] <file>` 删除文件
    * `file` 要删除的文件路径
    * `-f` 强制删除所有文件, 忽略不存在的文件
    * `-r` 递归删除目录即目录下的文件, 默认情况下只能删除文件, 如果需要删除文件夹即文件夹下的文件, 需要使用此命令
    * `-i` 在每个文件被删除前进行确认
* `mv [-i] <src> <dest>` 移动 (重命名) 文件或文件夹
    * `src` 被移动文件的路径
    * `dest` 移动目标路径
    * `-i` 如果 `dest` 存在, 则进行覆盖查询, 否则将直接覆盖
* `touch <file>` 更新 / 创建空文件
    * `file` 当文件存在时, 将更新文件修改时间, 否则创建空文件
* `cat [-n] <file>` 输出文件内容  
    * `file` 要输出的文件路径
    * `-n` 显示行号
* `tail [-n<num>] [-f [-pid=<pid>]] <file>` 观察文件内容, 与 `cat` 不同, 该命令一般用于观察不断修改的文件, 可用于查看非文档的特殊文件或正在运行程序的日志文件  
    * `-n<num>` 显示文件的最后 `num` 行内容, 默认为 10 行
    * `-f` 读取不断刷新的文件, 一般开启此选项
    * `-pid=<pid>` 刷新读取, 直到线程 `pid` 结束
    * `file` 读取的文件路径

关于查询文件属性的命令见[文件属性](#查看文件属性)小节的介绍

#### 基础目录管理
* `pwd` 获取当前工作文件夹
* `cd <dir>` 修改当前工作文件夹
    * `dir` 文件夹路径
* `mkdir [-p] <dir>` 新建文件夹
    * `dir` 新建的文件夹路径
    * `-p` 当给出路径的父文件夹不存在时, 自动递归创建
* `rmdir [-p] <dir>` ==删除空文件夹==
    * `dir` 删除的文件夹路径
    * `-p` 当文件夹的父目录为空时, 一同删除

#### 路径查询
* `dirname <文件路径>` 获取文件所在目录
* `basename <文件路径>` 获取文件
* `realpath <文件路径>` 将路径格式转换为绝对路径

#### 链接
命令 `ln` 可用于创建软链接或硬链接

`ln [-sd] <src> <dest>`
* `-s` 创建软链接 (默认为硬链接)
* `-d` 创建关于目录的硬链接 (需要管理员权限)
* `src` 目标被链接文件
* `dest` 创建的链接文件

关于软链接与硬链接有区别
* 软链接 (符号链接)
    * 软链接的本质为一个指向被链接文件的文件
    * 当被链接文件被删除时, 软链接失效
    * 软链接可以跨文件系统创建
* 硬链接
    * 硬链接本质为一个文件, 多个名称
    * 硬链接与被链接文件指向同一块存储空间
    * 当文件被删除时, 文件依然存在, 链接依然有效
    * 硬链接不可跨文件系统创建

#### 查找文件
命令 `find` 可用于通过文件的基本属性, 查找需要的文件, 对查找结果的处理需要在命令中确定

`find [dir] [expression] [act] \;`
* `dir` 要查找的目录
    * 可以有多个目录, 使用空格划分
    * 没有给出时默认为当前工作目录
    * 注意, ==目录的末尾需要有 `/`==
* `expression` 查找条件, 允许多个查找条件同时使用, 常用的有
    * `-name <文件名>` 按文件名筛选, 支持通配符 `*` 与 `?`, 使用时最好加上 `"`
    * `-type <文件类型>` 按文件类型筛选, 有文件类型
        * `f` 一般文件
        * `d` 目录
        * `l` 链接
    * `-size <比较方式><文件大小><大小单位>` 按文件大小筛选
        * 比较方式: 使用 `+` 表示大于, `-` 表示小于
        * 文件大小: 配合单位使用
        * 大小单位: 常用的单位有 `c` 字节, `k` kb, `M` mb, `G` gb
    * `-[a|c]time <比较方式><天数>` 按时间筛选
        * `[a|c]` 使用 `a` 表示查询最近访问时间, 使用 `c` 表示查询最近修改时间
        * 比较方式: 使用 `+` 表示指定天数前, 使用 `-` 表示指定天数内, 无修饰表示指定天数时
        * 天数: 即 24 小时
* `act` 对查找结果执行动作, 一般位于最后  
    * `-exec <命令> \;` 对查找结果执行命令, 并且命令中使用 `{}` 代替查找结果, 使用 `\;` 表示命令结束, 常用有
        * `-exec ls -l {} \;` 查看查找结果的详细信息
        * `-exec rm -i {} \;` 删除查找到的结果
    * `-print[0]` 打印查找结果  
        * 默认每个结果间都以换行分割, 加上 `0` 则使用 `\0` 分割
        * 当文件名过长时可能导致 `-exec` 发生错误, 此时推荐使用该选项配合[管道与 xargs 命令](#参数传递过滤器)实现类似效果

#### 内容搜索
命令 `grep` 使用正则表达式, 可用于搜索单个文件, 多个文件以及标准输出 (使用管道或重定向) 中的内容

命令的基本格式为 `grep [options] [files]`
命令的常用的选项有
* 搜索设置
    * `-v` 反向搜索不符合条件的内容 
    * `-i` 搜索时忽略大小写
    * `-F` 仅匹配字符串, 不使用正则表达式
    * `-E` 使用扩展正则表达式 (建议开启)
    * `-e<表达式>` 待搜索的表达式, 默认为正则表达式  
    使用时建议以 `"` 包裹表达式
    允许有多个, 如果只有一个可省略 `-e`  
* 结果显示设置
    * `-n` 显示匹配行的行号
    * `-o` 只显示匹配到的文字 (默认将显示匹配结果所在的整行)
    * `-Z` 使用 `\0` 分割结果, 一般用于配合[参数传递过滤器](#参数传递过滤器)进行下一步处理
* 多文件设置
    * `-r` 搜索文件内容时, 递归查找目录中的所有文件
    * `--include <文件名>` 配合 `-r` 使用, 仅搜索目录下具有指定文件名的文件 (可使用 `*`, `?` 作为通配符, 建议使用 `"` 包裹文件名)
    * `--exclude <文件名>` 配合 `-r` 使用排除目录下具有指定文件名的文件 (可使用 `*`, `?` 作为通配符, 建议使用 `"` 包裹文件名)

对于命令的 `files` 参数
* 可以给出多个文件用于搜索
* 如果启用了 `-r`, 还可以搜索指定文件加下的所有文件
* 还可以通过[管道](#管道), 搜索命令的结果

#### 浏览文件内容
`less [-fNx] <file>`
* `file` 要浏览的文件名 (除了指定文件名, 也可通过[管道](#管道)接收并浏览命令的输出)
* `-f` 强制打开二进制, 设备与目录等非文档文件
* `-N` 显示行号
* `-x<数字>` 规定 <kbd>tab</kbd> 的显示为指定个数的空格

在浏览文件时, 可使用以下按键操作 (这一系列操作对于 `man` 命令同样适用)
* `/<str>` 向下搜索字符串 `str`
* `?<str>` 向上搜索字符串 `str`
* <kbd>n</kbd> 重复上一次搜索
* <kbd>N</kbd> 反向重复上一次搜索
* <kbd>b</kbd> 向上翻动一页, 也可使用按键 <kbd>pageup</kbd>
* <kbd>Space</kbd> 向下翻动一页, 也可使用按键 <kbd>pagedown</kbd>
* <kbd>y</kbd> 向上移动一行, 也可使用按键 <kbd>up</kbd>
* <kbd>Enter</kbd> 向下移动一行, 也可使用按键 <kbd>down</kbd>
* <kbd>q</kbd> 退出浏览

### 文件权限
#### 文件属性
* 文件类型
    * `d` 目录文件
    * `l` 软连接
    * `c` 串行端口设备
    * `-` 一般文件
* 文件权限
    * `r` 读取权限
    * `w` 写入权限
    * `x` 执行权限
    * `-` 无权限
* 文件属性字符
    * 0 位表示文件类型
    * 1-3 位确定文件所有者的权限 (owner, u)
    * 4-6 位确定与文件所有者同组的权限 (group, g)
    * 7-9 位确定其他用户的权限 (other, o)
* 权限数字表示  
将文件属性字符的 1-3, 4-6, 7-9 位分别视为一个三位二进制数  
该二进制数的第一位对应 `r`, 第二位对应 `w`, 第三位对应 `x`  
当取 `0` 时, 表示 `-` 即无权限  
例如 `761` 对应了属性字符 `rwxrw---x`

注意
* 对于 root 用户, 不受权限影响
* 默认情况下创建文件的权限为 `rw-r--r--`

#### 查看文件属性
`ls [-luRa] [path]`

参数
* `path` 路径
    * 如果给出目录路径, 则将列出该文件夹下所有文件的信息
    * 如果给出文件路径, 则将列出该文件的信息
    * 如果没有给出路径, 则将列出当前工作目录下所有文件的信息

选项
* `-l` 默认情况下仅会列出文件名, 如果启用该选项, 还将列出文件的详细属性
* `-u` 需要配合选项 `-l` 使用, 详细信息中显示最后访问时间 (默认显示的时最后修改时间)
* `-R` 将递归显示文件夹下的文件信息
* `-a` 显示隐藏文件 (即以 `.` 开头的文件)

对于查看复杂目录结构, 更推荐使用 [tree](#查看文件结构) 命令  
该命令可配合 [grep](#内容搜索) 筛选信息

#### 通过权限数字修改文件权限
`chmod [-R] <xyz> <file>`  

参数
* `xyz` 文件新的权限数字
* `file` 文件或目录名

选项
* `-R` 如果选择的是目录, 则递归修改该目录下所有文件

#### 通过符号类型修改文件权限
`chmod [-R] u[= | + | -]<ur> g[= | + | -]<gr> o[= | + | -]<or> <file>`

参数
* `ur` 文件所有者的权限字符
* `gr` 文件所有者同组用户的权限字符
* `or` 其他用户的权限字符
* `file` 文件或目录名
* `= | + | -` 分别表示设置, 新增, 删除权限

选项
* `-R` 如果选择的是目录, 则递归修改该目录下所有文件

### 软件下载与安装
#### 软件安装与管理
此处介绍的为 Debian 与 Ubuntu 下的包管理工具 apt

`apt [-yq] [command]`
* 命令选项
    * `-y` 安装过程自动确认
    * `-q` 静默安装
* 常用的管理操作有
    * `install <package>[=<version>] [--no/only-upgrade]` 安装指定软件包
        * `version` 安装指定版本号的软件包
        * `--no-upgrade` 如果已经安装, 则不进行升级
        * `--only-upgrade` 仅当已安装时, 升级该软件包
        * 一般可使用 <kbd>Tab</kbd> 补全包名, 避免搜索
    * `<remove | purge> <package>` 删除指定软件包
        * `remove` 仅删除软件包
        * `purge` 同时删除软件包与其配置文件
* 常用的更新操作有
    * `update` 获取可更新的软件包
    * `list --upgradable` 列出可更新的软件包
    * `[full-]upgrade` 升级所有可更新的软件包
        * `full-` 通过重新安装的方式更新软件包
    * `autoremove` 清理不再使用的依赖和库文件
* 常用的查询操作有
    * `list [--upgradeable | --installed | --all-versions] [package]` 根据软件包名搜索, 可以使用通配符
        * `--upgradeable` 仅搜索可升级的软件包
        * `--installed` 仅搜索已安装的软件包
        * `--all-versions` 列出同一软件包的所有版本
        * `package` 省略时将列出所有软件包
    * `search <keyword>` 根据关键词搜索软件包, 可以使用通配符
    * `show <package>` 显示软件包的详细信息

注意, 在 Shell 脚本等环境下, 建议使用 `apt-get` 代替, 二者基本相同

#### 软件包安装
在 Debian 类的 Linux 系统下, 除了 apt, 还可使用命令 dpkg 管理软件包    
该命令与 apt 类似, 但不包含下载功能, 用于安装下载得到的软件包 (一般有后缀 `.deb`)

通常的使用方式有
* `dpkg -i <file>` 安装软件包 `file` (一般有后缀 `.deb`)
* `dpkg -r <pkg>` 卸载名称为 `pkg` 的软件包
* `dpkg -P <pkg>` 卸载软件包 `pkg`, 并清除配置文件
* `dpkg -l` 列出所有软件包, 可通过类似 [less](#浏览文件内容) 命令的方式浏览内容
* `dpkg -s <pkg>` 显示软件包的详细信息
* `dpkg -L <file>` 显示软件包的安装文件

#### 文件下载
参考资料 <https://blog.csdn.net/m0_71218711/article/details/135465743>

使用命令 `wget` 用于下载文件, 常用的使用方式有
* `wget [-cbr --spider] [-o] [-P/O] <url>`
    * `-c` 从上次中断的位置继续下载
    * `-b` 在后台进行下载, 可配合命令 [tail](#基础文件管理) 查看后台下载日志 (此时默认为 `./wget-log`) 实现观察下载进度的效果
    * `-r` 递归下载指定 `url` 下的所有文件
    * `--spider` 仅测试 `url` 是否有效
    * `-o <log>` 将日志文件保存至路径 `log`, 默认为直接输出到控制台
    * `-P <dir>` 将下载结果保存到文件夹 `dir` 中
    * `-O <file>` 将下载结果另存为 `file`
    * `url` 文件链接地址, 支持 `http`, `https`, `ftp` 等协议

#### 文件压缩与存档
参考文档 <https://blog.51cto.com/u_15346415/5093448>  
使用命令 `tar` 完成文件的压缩以及存档

该命令的基本形式为  
`tar [act][method][opt] [dest] [dir]`

该命令的参数主要由以下部分组成
* `act` 执行的动作
    * `-c` 创建压缩文档
    * `-x` 解压缩
    * `-t` 列出压缩文档内的内容  
    该动作仅需要 `-f` 指定压缩文档, 可配合 [grep](#内容搜索) 进一步筛选
* `method` 压缩方法 (以下选项相互排斥)
    * `-a` 根据文件后缀自动识别  
    * 不指定压缩方法
        * 使用后缀 `.tar`  
        * 此类数据没有压缩, 仅是将目录归档为一个文件
    * `-z` 使用 gzip 作为解压与压缩工具  
        * 使用后缀 `.tgz` 或 `.tar.gz`
        * 压缩时间最快, 压缩率最低, 使用最广泛
        * 一般用于压缩小文件
    * `-j` 使用 bzip2 作为解压与压缩工具  
        * 使用后缀 `.tbz` 或 `.tar.bz2`
        * 压缩时间与压缩率适中
        * 一般用于压缩大文件
    * `-J` 使用 xz 作为解压与压缩工具  
        * 使用后缀 `.txz` 或 `.tar.xz`
        * 压缩时间最慢, 压缩率最高
        * 一般用于压缩大文件
    * `-Z` 使用 compress 作为解压与压缩工具  
        * 使用后缀 `.taz` 或 `.tar.Z`
        * 几乎不使用
* `opt` 其他设置选型
    * `-v` 显示操作的详细过程
    * `-p` 保留文件的原始属性 (常用于备份)
    * `--exclude=<file>` 解压 / 压缩时排除指定文件或目录  
    解压时, 使用 `-t` 获取的压缩文件内路径表示
* `dest` 目标确定
    * `-C <dir>` 仅用于解压, 设置解压结果存放的文件夹
    * `-f <archive>` 指定压缩文件的名称. 该选项必须位于最后 (包括压缩结果与解压目标)  
    压缩时, 建议按上方的后缀标准, 根据压缩方法选择后缀
    * `file` 文件参数 
        * 压缩时表示目标被压缩的目录或文件
        * 解压时表示解压的文件或目录 (文件使用 `-t` 获取的压缩文件内路径表示), 为空则解压整个文件

### 系统与用户管理
#### 用户管理与设置
关于用户组管理有
* `groupadd <用户组名>` 创建用户组
* `groupdel <用户组名>` 删除用户组
* 获取用户组信息  
    * 通过查看文件 `/etc/group` 可查询用户组信息  
    每行各一条信息, 表示格式为 `组名:口令:组编号:用户`

关于用户管理有
* `useradd [-c] [-g] [-s] [-G] <用户名>` 添加用户
    * `-c <comment>` 用户描述, `comment` 为描述内容
    * `-g <用户组>` 用户所属用户组
    * `-G <用户组1>,<用户组2>,...` 用户所属的附加组  
    如通过设置用户为 `sudo` 的附加组可使其成为超级用户
    * `-s <Shell 程序>` 用户的登录 Shell 程序
    * `用户名` 添加用户的用户名
    * 注意, 用户创建后
        * 用户将处于锁定状态无法登录, 需要使用 `passwd <用户名>` 设置密码
        * 用户的主目录 `home/<用户名>` 可能不存在, 需要创建 
* `usermod [-c] [-g] [-s] [-G] <用户名>` 修改用户  
    * 该命令的设置选项含义与 `useradd` 一致
    * `-aG` 使用 `-G` 将覆盖附加组, 可使用该选项可添加附加组 
    * `用户名` 被设置用户的用户名
* `userdel [-r] <用户名>` 删除用户
    * `-r` 同时删除用户的主目录
    * `用户名` 被删除用户的用户名
* `passwd [-lud] [用户名]` 设置用户密码 (非超级用户仅能使用该命令修改自己的密码)
    * 如果没有选项, 则为修改用户密码 (该方式也可以解封被 `-l` 禁用的账户)
    * `-l` 禁用账户, 此时用户将无法登录  
        * 可用于封禁 `root` 用户以保护系统
        * 通过 `useradd` 创建的用户默认为禁用状态
    * `-u` 解禁账户, 仅用于设置过密码的被封禁账户
    * `-d` 删除密码, 此时用户登录不需要密码
* 获取用户信息
    * 通过查看文件 `/etc/passwd` 可查询用户基本信息 (所有用户均可查看)  
    每行各一条信息, 表示格式为  
    `用户名:密码:用户标识号:组标识号:注释性描述:主目录:登录Shell`
    * 通过查看文件 `/etc/shadow` 可查询高级用户信息  
    每行各一条信息, 表示格式为  
    `登录名:加密密码:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志`

关于用户登录
* `whoami` 获取当前用户名
* `su [-c | -m | -l | -s] <name>` 切换用户
    * `-c <cmd>` 切换为指定用户执行指令 `cmd` 后回到当前用户
    * `-m` 切换到指定用户后保持当前的环境变量
    * `-l` 切换到指定用户并重置环境变量
    * `-s <shell>` 使用指定的 Shell 程序 `shell` 登录用户
    * `name` 用户名称, 默认为 `root`
* `sudo <cmd>` 以超级用户的方式执行命令  
    * 通过该命令, 即使不登陆 `root`, 使一般用户也能以超级用户的方式执行特殊命令
    * 仅文件 `/etc/sudoers` 中标注的使用者可以使用此命令
    * 通过修改 `/etc/sudoers` 可对该命令的使用者进行设置, 设置方法见此文件中的注释
    * 一般情况下, `root` 用户与附加组为 `sudo` 的用户可使用 `sudo`

#### 环境变量设置
* `export <变量名>=<变量值>` 设置 / 创建当前终端的环境变量  
    * 变量定义可参考 [Shell 变量定义](变量定义)
    * 在原变量上增加内容如 `PATH` 可使用 `PATH=$PATH:<新内容>`, 其中 `:` 为 Linux 下 `PATH` 的路径分隔符
* `unset <变量名>` 删除环境变量
* `env [-0]` 打印所有环境变量
    * `-0` 使用 `\0` 分隔各条结果, 而不是 `\n`
* `reset` 重启当前终端 (以此重置所有环境变量设置)

注意, 以上设置仅在当前终端生效  
如果希望设置全局环境变量, 可通过设置 Shell [启动时执行脚本](#启动时执行)实现
* 配置全局的环境变量, 则应在文件 `/etc/profile` 中使用 `export` 命令定义
* 配置用户的环境变量, 则应在文件 `~/profile` 中使用 `export` 命令定义

#### 系统进程管理
* `ps [-au]` 查询系统进程状态 (可配合 [grep](#内容搜索) 筛选信息)
    * `-a` 显示所有进程
    * `-u` 显示进程的详细信息
* `pstree [-ap]` 显示系统进程树
    * `-a` 显示进程的详细信息
    * `-p` 显示进程的 PID
* `kill [-s | -l | <pid>]` 终止指定进程
    * `pid` 终止进程的 `pid`, 使用默认方式终止进程 (发送信号 `SIGTERM`)
    * `-l` 列出所有进程终止信号的名称与序号
    * `-s <sig> <pid>` 使用指定信号 `sig` (可以给出完整名称或序号) 终止进程 `pid`  
    常用的信号有
        * `SIGTERM` 正常方式退出进程
        * `SIGHUP` 重新加载进程
        * `SIGKILL` 强制退出进程
* `pkill [-<n>] <name>` 杀死指定名称的进程
    * `-<n>` 杀死进程的信号的编号 (使用 `kill -l` 获取), 默认为 `SIGTERM`
    * `name` 进程名称
        * 一般即进程的程序名, 不包括参数
        * 可以使用通配符 `*`, `?`, 推荐使用 `"` 包裹
        * 可以一次性杀死多个同名的进程

#### 系统关闭相关命令
* `sync` 将内存中的数据保存到硬盘中, 在关闭或重启系统前, 都应当执行这一命令
* `shutdown [-hprc] [time] ["message"]` 停止, 关闭, 重启系统
    * `-H` 停止系统, 此时系统仍然通电处于最低维护状态, 默认操作
    * `-p/h` 关闭系统, 此时系统断电, 部分情况下与 `-H` 相同
    * `-r` 重启系统
    * `-c` 取消计划中的操作
    * `time` 计划时间, 常用的表示有
        * `now` 立刻执行 (默认)
        * `+m` 在 `m` 分钟后执行
    * `message` 执行该命令后, 打印信息
* `exit` 退出当前终端

#### 系统服务管理
服务即一类特殊的程序, 这些程序通常在开机时启动, 并运行在后台  
使用命令 `systemctl` 管理系统的服务

常用的命令有
* 查询服务
    * `systemctl list-units [PATTERN]` 查询当前正在运行的所有服务  
    `PATTERN` 匹配的服务名称, 可使用通配符, 默认为所有服务  
    由于服务名称不确定, 推荐使用 `*...*` 的方式查询所需的服务
    * `systemctl list-unit-files [PATTERN]` 查询当前系统安装的所有服务  
    要求与 `list-units` 相同
* 管理当前的服务 
    * `systemctl start <NAME>` 启动指定名称的服务  
        * `NAME` 服务名称, 默认可以不带后缀 `.service`
    * `systemctl restart <NAME>` 重启指定名称的服务 (当服务的配置修改时, 应当通过此命令使之生效)  
    * `systemctl stop <NAME>` 停止指定名称的服务  
    * `systemctl status <NAME>` 获取指定名称服务的运行状态  
* 配置服务
    * `systemctl enable <NAME | PATH>` 安装服务, 服务在安装后将在开机时自动启动
        * `NAME` 服务名称也即服务配置文件名称, 默认的搜索路径为 `/etc/systemd/system`
        * `PATH` 服务配置文件路径, 关于服务配置文件见创建服务的介绍
    * `systemctl disenable <NAME>` 解除指定服务的安装
* 创建服务  
通过创建服务, 可实现开机自动启动的效果, 但更推荐使用 [crontab](#定期执行任务) 实现开机与定期执行任务  
关于这部分内容, 可参考 <https://www.kancloud.cn/lengyueguang/linux/2042523>

### 其他实用命令
#### 查看文件结构
使用命令 `tree` 可以查看目录下文件的详细结构

`tree [-asC] [-L] [dir]`
* `-a` 显示所有文件
* `-s` 显示文件或目录的大小
* `-C` 以彩色的方式显示
* `-L <n>` 最多显示 `n` 层目录
* `dir` 查询结构的根目录, 默认为当前目录

#### 定期执行任务
参考教程 <https://zhuanlan.zhihu.com/p/58719487?utm_source=wechat_session>

安装 crontab  
1. 通过安装指令安装 `crontab`
1. 检查服务 `cron` 或 `crond` [是否安装](#系统服务管理)

使用以下命令进入配置文件
`crontab [-u] [-e | -l]`   
* `-e` 进入配置文件编辑
* `-l` 打印配置文件, 可配合[重定向](#重定向)以备份配置
* `-u <user>` 设置由指定用户执行的定期任务, 默认为 root

配置文件的基本格式为
```
# 注释

SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=""
HOME=/

<time>  <command>
...
```

其中
* 基本参数 (一般按示例即可) 
    * `SHELL` 执行命令时的 Shell 程序路径
    * `PATH` 环境变量 `PATH` 的值
    * `MAILTO` 将任务输出发送到指定用户的邮箱, 一般设置为 `""`, 即不发送
    * `HOME` 环境变量 `HOME` 的值
* `time` 命令执行时间
    * 对于指定日期与时间的任务, 可参考 <https://crontab.guru/>
    * 可使用符号表示特定任务, 常用的有
        * `@reboot` 开机时执行
        * `@daily` 每天执行
        * `@monthly` 每月执行
* `command` 待执行的命令, 注意
    * 命令中, 使用 `%` 表示换行, 因此要使用 `\%` 表示一般换行
    * 推荐使用 shell 脚本组织复杂的操作
    * 为了防止环境变量导致的问题, 推荐命令中使用完整的绝对路径, 并且在脚本开始时使用 [source](#运行脚本) 命令导入 `/etc/profile`, `~/.profile`, `~/.bashrc` 等[环境变量](#环境变量设置)文件
        * 更推荐的方法是在脚本目录下定义一个设置环境变量的脚本文件, 每次只需要引入该文件即可
        * 对于开机启动的程序, 还应当通过 `sleep` 命令休眠一段时间, 等待系统完全启动
    * 可通过[重定向](#重定向)的方式获取自动执行任务的输出

#### 其他实用命令
* `man <命令名称>` 获取命令的详细帮助, 一般情况下使用该命令可获得比 `--help` 更详细的信息  
查看文档的方式与 [less](#浏览文件内容) 相同
* `whereis <命令>` 查询命令对应的应用程序与库所在地址
* `free [-ht] [-s]` 查看当前内存状态
    * `-h` 以易于阅读的方式显示信息 (主要为使用 `数字 + 大小单位` 的方式显示, 默认以 `kb` 为单位)
    * `-t` 显示统计信息
    * `-s<x>` 持续观察, 且每间隔 `x` 秒更新一次状态 
* `df [-ha] [--total]` 查看当前磁盘的剩余空间 (Disk Free)
    * `-h` 以易于阅读的方式显示信息 (主要为使用 `数字 + 大小单位` 的方式显示, 默认以 `kb` 为单位)
    * `-a` 显示所有文件系统类型的磁盘
    * `--total` 显示所有硬盘的统计信息
* `ip [-s] [-c] <object> show` 查询网络状态 (该命令也可用于设置网络, 但此处不介绍)
    * `-s` 显示详细信息
    * `-c` 使用彩色显示信息
    * `object` 查询对象, 常用的对象有
        * `link` 网络设备
        * `address` 网络地址
* `time <command>` 计算运行命令 `command` 所消耗的时间 (该命令在 bash 与 zsh 上的表现不同)
* `date [+"format"]` 获取当前时间
    * `format` 使用格式 `format` 输出, 设置可参考 <https://www.runoob.com/linux/linux-comm-date.html>  
    常用的格式有 `%F` 显示当前完整日期, 可用于日志名称, `%T` 显示当前完整时间

## Shell 笔记
### Shell 基本介绍
Shell 是一种用于访问系统内核服务的应用程序  
实际上 Windows Explorer 属于一种图形界面的 Shell 程序

而在 Linux 中的 Shel 程序如 bahs, 主要使用命令的方式交互  
其中用于控制 Shell 完成功能的命令语言也是编程语言则称为 Shell 脚本  
以下 Shell 笔记以介绍 bash 下的 Shell 脚本的编写为主

#### Shell 程序
在 Linux 中, 常用的 Shell 程序有
* sh 最基础的 shell, 解释器一般位于 `bin/sh` (注意该笔记中的部分语法可能不被 sh 支持)
* bash 在 sh 基础上改进的 shell, 通常是 Linux 系统的默认解释器, 解释器一般位于 `bin/bash`
* zsh 功能更强大的 shell, 但一般额外需要安装, 语法与 bash 存在一定差异, 安装后解释器位于 `bin/zsh`

#### Shell 脚本
可以创建文本文件, 并在文本内写入 Shell 脚本供 Shell 程序解释并执行

约定 Shell 脚本的第一行为 `#!<解释器路径>`  
通过该语句规定执行该脚本所用的解释器, 对于 php, python 等脚本同理

Shell 脚本文件的拓展名则无具体要求, 一般以该脚本使用的 Shell 程序为拓展名, 如 `.zsh`, `.sh` 等

#### 运行脚本
可通过以下四种方式执行脚本
* 通过指定的解释器执行脚本文件 `<解释器> <脚本文件路径>`  
注意应当前目录下的文件应当使用相对路径 `./<脚本文件名>`
* 将脚本视为可执行程序运行 `<脚本文件路径>`  
使用该方法时, 脚本文件需要有[执行权限](#文件属性)
* 使用当前 Shell 环境执行脚本文件 `source <脚本文件路径>`  
    * 通常可以使用 `.` 代替 `source`
    * 以上两种方式都是在新终端中执行脚本, 但 `source` 语句是在当前终端执行脚本, 因此其中定义的变量都会被作为环境变量保留下来, 因此该语句一般用于执行终端的初始化脚本
    * 此外也可将该语句用于 bash 脚本中, 类似于导入其他的 bash 脚本
* 直接向 Shell 终端程序输入脚本, 如以下的 bash 脚本语句均可在 bash 终端下输入并运行, 此时==需要使用 `;` 代替换行==

#### 基本语法
在 Shell 脚本中, 使用 `#` 作为单行注释  
使用 `: '` 作为注释开头, `'` 作为注释结尾, 实现多行注释

除了如 `if` 等程序控制关键字以及定义的子命令 (函数), 每个语句都相当与执行一个程序 (对于命令实际对应的程序可通过指令 [whereis](#其他实用查询命令) 查询), 且都是 `程序路径 + 参数` 的格式, 一般也将这些语句称为命令  
因此可通过 bash 脚本组织一系列命令的执行, 减少重复输入命令

使用命令时注意
* 当程序在环境变量 `PATH` 下时, 可直接输入程序名以执行这些程序, 对于绝大部分的 Linux 命令都是以方式执行的
* 否则需要给出程序的完整路径, 例如执行当前目录下的 python 脚本程序使用 `./script.py`, 运行 `bash` 程序使用 `/bin/bash`
* Shell 使用换行区分语句, 在终端中则可使用 `;` 代替换行, 因此 `<命令1>;<命令2>` 可在终端中执行多个命令

在 bash 中, 最常使用的命令即 `echo "<字符串>"`, 该命令可向交互界面打印字符串

### 变量
#### 变量定义
使用 `<变量名>=<变量初值>` 的语法即可定义一般变量  
* 定义变量时, `=` 两侧不应有空格, 否则可能导致错误
* 一般使用字母, 数字, 下划线的组合作为变量名 (不能以数字开头)
* 如果要定义常量, 则应在变量定义后, 使用 `readonly` 修饰变量, 且常量一般使用大写字母作为变量名
* 不建议在 bash 中使用浮点数与浮点运算, bash 仅会将这些数作为字符串处理
* 使用命令 `read <变量名>` 则将从控制台读取用户输入为变量赋值, 如果变量不存在将自动创建

变量初值除了整数, 以及接下来介绍的字符串与数组, 可以使用 `$(命令)`, 此时将被包裹的内容视为脚本并运行, 然后将结果返回  
* 可使用此方法来获取查询命令的结果, 如 `a=$(pwd)` 可获取当前工作目录, `a=$(cat ${path})` 可读取 path 中的文件内容
* 在命令中使用 `${变量名}` 也将自动取变量值, 可使用此方法将变量值传入命令
* 语法 `` `命令` `` 与 `$(命令)` 效果相同, 笔记中以后者为主

#### 使用变量
* 通过 `${<变量名>}` 即可访问变量的值 (一般情况下可省略大括号)  
* 对变量重新赋值的方式与变量定义相同, 不需要加 `${...}`
* 使用 `unset <变量名>` 即可删除指定名称的变量
* 对于环境变量, 可使用 `$<变量名>` 的方式访问
* 此外还有一些特殊变量
    * `$0` 表示当前脚本路径 (不包含参数与 Shell 程序), 可配合 [dirname](#路径查询) 获取脚本所在目录
    * `${n}` 运行脚本时给出的第 n 个参数 (当 n 小于 10 时, 可省略大括号)
    * `$#` 传递给脚本的参数数量
    * `$?` 上一个命令的退出状态 (一般执行==成功时为 `0`, 失败时为 `1` 或任意非零值==)
* 使用命令 `declare -p <变量名>` 可以获取变量的类型与值信息

#### 字符串
可以使用 `'` 或 `"` 包裹字符表示字符串, 但两者存在区别
* 使用 `'` 时, 不会对字符串内的内容做转换 (包括变量与转移字符)
* 使用 `"` 时, 能解析 `${<变量值>}` 对应的变量值, 以及使用 `\` 转移

对于字符串变量 `str`, 可使用以下语法访问字符串的信息
* `${#str}` 获取字符串的长度
* `${str:<ind>:<size>}` 获取字符串在索引 `ind` (从 0 开始索引) 及之后最多 `size` 个字符的子字符串  
当 `size = 1`, 即可以访问特定索引位置的字符
* `${str/<str1>/<str2>}` 将 `str` 中第一个匹配 `str1` 的子字符串替换为 `str2`
* `${str//<str1>/<str2>}` 与上一个相同, 但该命令可以替换所有匹配的子字符串
* `${str/<str1>}` 将 `str` 中第一个匹配 `str1` 的子字符串删除
* `${str//<str1>}` 与上一个相同, 但该命令可以删除所有匹配的子字符串

使用命令 `expr index "${str}" <字符>` 可用于查询字符在字符串中最早出现位置的索引  
如果希望保存结果, 则需要 `res=$(exper index "${str}" <字符>)`  
对于其他字符串处理, 也可通过命令 `expr` 完成, 具体见 `expr --help`

#### 数组
使用语法 `(元素1 元素2 ...)` 可以定义一个一维数组
* 数组的索引从 0 开始
* 注意使用空格划分元素
* bash 不支持多维数组

使用语法 `declare -a <变量名>=([索引1]=元素1 [索引2]=元素2 ...)` 可以定义关联数组
* 使用改语法时不一定要声明初值, 可以定义后再赋值

修改数组时 (对于数组 `x` 为数组, 对于关联数组 `x` 为键)
* 使用 `${arr[x]}` 访问数组 `arr` 的第 `x` 个元素
* 使用 `arr[x]=<新值>` 为数组第 `x` 个元素赋值, 如果对不存在的索引赋值则将自动创建, 因此数组的索引可能不连续
* 使用 `${arr[*]}` 获取数组内的所有元素, 通常使用此方法打印数组内的所有元素
* 使用 `${#arr[*]}` 获取数组的长度
* 使用 `${!arr[*]}` 获取数组所有有效的索引

### 运算
#### 数学运算
使用 `$[数学运算表达式]` 或 `$((数学运算表达式))` 表示数学运算 (注意 bash 仅支持整数运算)  
主要支持的运算有
* `$[${a} + ${b}]` 相加
* `$[${a} - ${b}]` 相减
* `$[${a} * ${b}]` 相乘
* `$[${a} / ${b}]` 相除 (向下取整)
* `$[${a} % ${b}]` 取余

如果希望计算浮点数与数学函数, 可能需要借助 `$()` 并执行如 `bc` 等计算指令

#### 关系运算
使用 `[[ 关系运算表达式 ]]` 表示关系运算 (注意 `[[]]` 与表达式之间要有空格)  
除了以上关系表达式, 也可使用 `test <关系运算表达式>`  
当关系表达式被运算后, ==如果表达式成立==, 则相当于命令执行成功, ==此时[特殊变量](#使用变量) `$?=0`==, 否则 `$?=1`

对于多个关系运算, 可使用以下运算符进行连接
* `!` 对运算结果取反
* `||` 逻辑或 (短路求值)
* `&&` 逻辑与 (短路求值)

#### 数值关系运算
常用的数值关系运算表达式有 (此处省略了 `[[ ]]`)
* `${a} -eq ${b}` 检测两个数是否相等
* `${a} -ne ${b}` 检测两个数是否不相等
* `${a} -gt ${b}` 检测变量 `a` 是否大于 `b`
* `${a} -lt ${b}` 检测变量 `a` 是否小于 `b`
* `${a} -ge ${b}` 检测变量 `a` 是否大于等于 `b`
* `${a} -le ${b}` 检测变量 `a` 是否小于等于 `b`

#### 字符串关系运算
常用的字符串关系运算表达式有
* `${str1} = ${str2}` 检测两个字符串是否相等 (注意只有一个等号)
* `${str1} != ${str2}` 检测两个字符串是否不同
* `-z ${str}` 检测字符串是否为空 (长度为 0)
* `-n ${str}` 检测字符串是否不为空 (长度不为 0)
* `${str}` 检测是否有字符串, 即任意字符串的表达式结果均为真, 不存在 false, 0 等表述

#### 文件关系运算
常用的文件关系运算表达式有 (注意, 以文件的路径字符串表示被检测的文件)
* `-f/d/c/L ${path}` 检测该路径是否指向一般文件, 目录, 设备, 连接
* `-r/w/x ${path}` 检测脚本对该文见是否有读取, 写入, 执行权限

### 流程控制
注意, 使用流程控制语句时, 换行方式最好与基本格式保持一致  
如果在终端中, 则可使用 `;` 代替换行

#### if 语句
if 语句格式如下
```shell
if 条件1
then
满足条件时执行 ...
elif 条件2
then
满足条件时执行 ...
else
否则执行 ...
fi
```

使用 if 时注意
* 允许有多个 `elif` 分支, 且 `elif` 与 `else` 不是必须的  
* if 中不允许有空的分支
* if 语句的条件本质为执行命令, 并根据命令是否执行成功判断 (`$?=0`), 因此可使用[关系运算](#关系运算)作为条件

#### case 语句
case 语句格式如下
```shell
case 判断值 in
情况1)
    满足情况执行 ...
    ;;
情况2)
    满足情况执行 ...
    ;;
esac
```

使用 case 注意
* 当判断值为数字时, 一般直接读取变量 `${a}` 即可
* 当判断值为字符串变量 `str` 时, 判断值需要表示为 `"${str}"`
* 使用 `|` 可以并列表示多个情况
* 对于其他情况, 可使用 `*` 代替

#### for 循环
指定循环次数时, for 循环的格式为 (注意空格)
```shell
for (( <定义>; <边界>; <步长> ))
do
循环执行的语句 ...
done
```

使用这种语法的 for 循环注意
* 其中的定义, 边界, 步长与 C 语言类似, 且定义时不需要知名类型  
例如 `(( i = 0; i < 10; i++ ))`, 则将进行十次循环 (`+=` 运算也支持)
* 该语法仅在部分 Shell 中支持, 如 zsh 与 bash, 但对于 ubuntu 的默认 Shell 程序 dash 不支持
* 迭代变量可通过 `${迭代变量名}` 访问

除了指定循环次数, for 循环还可用于遍历数组, 基本格式为
```shell
for <迭代变量名> in <迭代序列>
do
循环内容 ...
done
```

使用时注意
* 最简单的可通过 `元素1 元素2 ...` 表示迭代序列, 将按空格划分元素
* 如果给出一个字符串, 则也将一类似的方式解析, 即按空格或换行划分字符串, 迭代各个子字符串 (该特性仅用于 bash, 在 zsh 中将视为一个整体)
* 如果希望迭代数组, 可通过[数组信息](#数组), 使用 `${arr[*]}` 迭代数组元素, 或 `${!arr[*]}` 迭代数组索引
* 此外, 还可以使用命令 `seq <序列长度>` 生成指定长度的序列, 如 `$(seq ${n})` 将生成一个 1 - n 的序列, 完成 `n` 次循环, 实现类似指定次数循环的效果

#### while 循环
while 循环有基本结构
```shell
while 条件
do
循环内容 ...
done
```

使用时注意
* while 循环的条件与 [if 语句](#if-语句)相同
* 当条件为字符串 `true` 时, 为无限循环, 此时可通过 <kbd>Ctrl</kbd>+<kbd>D</kbd> 强制退出脚本
* 将 while 改为 until, 则变为 do-until 循环

#### 循环控制
对于 for 与 while 循环, 有如下循环控制语句
* `break` 退出循环
* `continue` 退出当此循环

#### 函数
使用如下方式即可定义函数, 其中关键字 `function` 不是必要的
```shell
function fun(){
    函数内容 ...
    return 返回值;
}
```

使用函数时注意
* 使用调用命令的方式调用函数, 如 `<函数名> [参数1] [参数2] ...`
* 函数中同样使用 `${n}`, `$#` 等[特殊变量](#使用变量)接收参数以及参数数量, 而不需要而外定义
* 函数执行后, 返回值将赋给特殊变量 `$?`
* 函数的返回值只能是 0-255 的整数, 且一般执行成功时返回 0, 也可以不设置返回值, 此时返回最后一条命令的状态
* 当函数的返回值为 `0` (表示 true) 或非 `0` 值时, 可将函数用于 [if 语句](#if-语句)的条件中
* 如果希望从函数中获取复杂信息, 则可使用 `$(命令)` 的方式调用函数, 接收函数通过 `echo` 输出的内容
* 可通过 `source` 指令[执行其他脚本](#运行脚本)的方式, 引入其他脚本中的函数
* 函数中定义的变量默认为全局有效, 如果希望定义局部变量, 需要在变量定义前加上关键字 `local`

### 高级使用技巧
#### 重定向
关于重定向的更多内容, 详见有关教程的介绍, 此处仅介绍基本使用

Linux 程序通过标准输入 `stdin` 读取信息, 并将信息输出到标准输入 `stdout` 中, 其中错误则输出到标准错误 `stderr` 中  
一般情况下标准输入, 标准输出, 标准错误均为终端, 且这三者在 Linux 都被视为文件, 分别有文件描述符 (类似文件句柄) `0, 1, 2`, 文件本体则位于目录 `/dev` 下

通过将 `stdout` 重定向为指定文件, 可实现将命令的输出保存到指定文件中  
* `command > file` 将命令的标准输出重定向为文件 `file` (可用变量, 字符串表示), 此时输出将覆盖文件 `file` 内原有的内容
* `command >> file` 将命令的标准输出重定向为文件 `file`, 此时输出将在 `file` 原有内容的基础上追加

通过将 `stdin` 重定向为指定文件, 可实现以已有的文件内容代替用户输入  
配合 [grep](#内容搜索) 等命令对结果内容进一步筛选
* `command < file` 将标准输入重定向为已有文件 `file` 
* `command << TAG ... TAG` 将标准输入重定向为使用 `TAG` 包裹的多行内容 (`TAG` 可以替换为任意英文组合), 可使用此方法在终端中输入多行内容 (==注意这不是命令的参数==)

使用时注意
* `command` 为==包括参数的完整命令==
* 重定向输出时, 文件 `file` 不存在时将自动创建; 重定向输入时, 文件 `file` 必须存在
* 对于 `stderr` 的重定向, 则使用 `2>` 与 `2>>` 代替
* 对于同一命令可设置多个重定向, 如 `command < infile > outfile 2> errfile` 将标准输入重定向为文件 `infile`, 标准输出重定向为文件 `outfile`, 标准错误重定向为文件 `errfile`
* 系统中有特殊文件 `/dev/null`, 该文件无法读取到任何内容, 且任何输入内容都会被丢弃, 因此可将标准输出重定向到该文件中, 以实现不显示命令输出的效果

#### 管道
重定向使命令能与文件之间进行交互, 如果希望多个命令之间进行交互, 则可使用管道符

管道的基本格式为 `命令1 | 命令2 | 命令3 ...`  
* 管道连接的各个命令将从做向右执行, 且上一个命令的标准输出都将重定向为下一个命令的标准输入
* 管道的命令无法从终端获输入, 但可通过[重定向](#重定向)为第一个命令提供输入以及重定向最后一个命令的输出
* 管道可以配合 [grep](#内容搜索) 等命令对结果内容进一步筛选, 实现查询命令结果的效果, 如 `ls | grep test` 将列出所有名称带有 `test` 的文件

#### 参数传递过滤器
注意, 无论时重定向还是管道, 都只能设置标准输入, 而无法设置命令的参数  
如果希望将标准输入转化为命令参数, 则可以使用命令 `xargs`  

使用 `xargs` 时, 首先将从标准输入接收信息, 然后解析接收到的信息  
1. 按指定规则将信息分割为多个命令参数
1. 按指定规则, 将这些参数分组
1. 将每组划分的参数与给出的命令拼接得到完整命令, 并执行各组命令

命令的基本格式如下

`xargs [-d<ch> | -0] [-n<x>] [-r] [-p] [-e<ch>] <command>`
* `-d<ch>` 设置参数间的分界符为 `ch`, 默认为空格
* `-0` 设置参数间的分界符为 `\0` (推荐将分界符设置为 `\0`, 以防止误将参数识别为分界符)
* `-n<x>` 以 `x` 个参数为一组执行命令, 默认为按换行划分
* `-r` 如果从标准输入没有接收到信息, 则停止执行命令
* `-p` 在执行各组命令前进行询问
* `-e<ch>` 当接收到字符 `ch` 时, 停止接收数据的处理
* `command` 待拼接的命令 (该命令也可以带参数, 拼接的参数将跟在后面)

例如[查找文件](#查找文件)时, 可使用此方法将查找结果分组作为 `ls -l` 的参数, 实现显示查找结果信息的效果, 如  
`find ... -print0 | xargs -0 ls -l` (该例子通过 `-print0` 与 `-0` 选项, 约定了以 `\0` 为参数分界符, 防止误将文件名识别为分界符)

#### 启动时执行
在 Shell 启动时 (不是系统启动), 将会执行一段特殊的 Shell 脚本  
可以在此脚本中完成设置环境变量, 定义函数等操作

一般情况下
* 针对所有 Shell 脚本, 启动时都将调用脚本 `/etc/profile` (全局) 与 `~/.profile` (用户)
* 针对特定脚本程序, 这些文件一般具有名称 `<Shell 程序名> + rc` (不固定)
    * 位于文件夹 `/etc/` 下时, 任何用户的 Shell 启动时都会运行该脚本
    * 位于文件夹 `~/` 下时, 该用户的 Shell 启动时将运行该脚本
